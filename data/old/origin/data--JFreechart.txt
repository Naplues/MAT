// this may be negative
// TODO: to be implemented
// TODO:  the subplot areas needs to be moved out of the plot into the plot //        state
//TODO: shift block down to bottom
// TODO: it might be a good idea to keep a reference to the color // specified in setPaint() or setColor(), rather than creating a // new object every time getPaint() is called.
// TODO: for now we are ignoring the height constraint
// first determine the size of the chart rendering area... // TODO workout insets for SWT
// TODO: implement properly
// TODO: this must be wrong...
// TODO: we didn't check the width yet
// hack to ensure the newly created awt fonts will be rendered with the // same height as the swt one
//TODO: shift block right by half
// FIXME: need a locale as well as a timezone
//TODO: shift block over to right
// do we need to update the crosshair values?
// TODO find a better localization key
// TODO:  this attribute should be transferred to the renderer state.
// FIXME: implement this, low priority
// FIXME: the XYItemRenderer interface doesn't specify the // getAnnotations() method but it should
// defer argument checking...
// calculate the adjusted data area taking into account the 3D effect... // this assumes that there is a 3D renderer, all this 3D effect is a // bit of an ugly hack...
// TODO:  add constructors for combinations of number and date formatters.
// TODO: move to plot state
// here we tweak the notify flag on the plot so that only // one notification happens even though we update multiple // axes...
// defer argument checking
//FIXME we should really assert a value here
// TO DO:  these annotations only work with XYPlot, see if it is possible to // make ContourPlot a subclass of XYPlot (DG);
//FIXME we should really assert a value
// not strictly necessary, since the // renderer set for the // parent plot is not used
// TODO : complete this
// TODO: fix output when this flag is set to true
// TODO:  move the above to the plot state
// FIXME:  this code means that it is not possible to use more than // one domain axis for the combined plots...
// end of workaround
// TODO: could change this to itemFillPaint().  For backwards // compatibility, it might require a useFillPaint flag.
// a redraw should NOT trigger another change event
// unused in parent
// TODO: In JFreeChart 1.2.0, put this method in the // CategoryItemRenderer interface
// TODO: rotate the image when drawn with horizontal orientation?
// TODO: implement this properly
// FIXME: this should generate a series change event
// CREATE ENTITIES // FIXME:  these methods should be defined
// FIXME: the renderer interface doesn't have the drawDomainLine() // method, so we have to rely on the renderer being a subclass of // AbstractXYItemRenderer (which is lame)
// FIXME: this attribute is not used - deprecate?
// TODO: by coding the event with some information about what changed // in the dataset, we could make the recalculation of the interval // more efficient in some cases (for instance, if the change is // just an update to a y-value, then the x-interval doesn't need // updating)...
// the method we want isn't in the CategoryItemRenderer // interface...
// FIXME: what if value is null on next line?
// TODO:  this needs to move into the renderer state
//TODO: implement this method properly
// hack to ensure the newly created swt fonts will be rendered with the // same height as the awt one
// unused but must return something, so while we are at it...
// FIXME: perhaps we should clone the data list
// if we are rendering the values as percentages, we need to calculate // the total for the current item.  Unfortunately here we end up // repeating the calculation more times than is strictly necessary - // hopefully I'll come back to this and find a way to add the // total(s) to the renderer state.  The other problem is we implicitly // assume the dataset has no negative values...perhaps that can be // fixed too.
// Note: It would be nice to pre-calculate this per series
// we assume that all other Paint instances implement equals() and // hashCode()...of course that might not be true, but what can we // do about it?
// FIXME: use other fields too
// all attributes are immutable, so we can just return the super.clone() // FIXME: in fact, the generator itself is immutable, so cloning is // not necessary
// here's a quirk - the API has been defined in terms of a plain // TimePeriod, which cannot make use of the timezone and locale // specified in the constructor...so we only do the time zone // pegging if the period is an instanceof RegularTimePeriod
// now handle specific plot types (and yes, I know this is some // really ugly code that has to be manually updated any time a new // plot type is added - I should have written something much cooler, // but I didn't and neither did anyone else).
// TODO: URLEncode?
// TODO Revert to SVN revision 2469 in JFreeChart 1.0.16 //      (MultipleGradientPaint's / JDK issues) // TODO THEN: change visibility of ALL darker(...) Methods EXCEPT //      darker(Paint) to private!
//TODO replace getSize by getBounds ?
// TODO: check threshold
// FIXME: add setBaseItemURLGenerator(CategoryURLGenerator, boolean) ?
// FIXME: add setSeriesItemURLGenerator(int, CategoryURLGenerator, boolean)?
// now we handle some special cases - yes, UGLY code alert!
// FIXME:  it probably makes sense to allocate an array of 256 Colors // and lazily populate this array...
// TODO: need to fetch this from localised resources
// FIXME: No getValueFormat() method?
// here we could probably be a little faster by searching for both // indices simultaneously, but I'll look at that later if it seems // like it matters...
// TODO: complete this
// FIXME: this attribute is never used - deprecate?
// FIXME: Clone the attributed string if it is not null
// report this?
// this may be obsolete (not used anywhere)
// TODO: is this a good idea?
/// a kludge to make everything work when no rows returned
//TODO: shift block down by half
// FIXME better ask the renderer instead of DatasetUtilities
// TODO: implement the entity for the annotation
// needs to be improved !!!
// not used by plot
// FIXME:  need a locale as well as a timezone
// TODO: For JFreeChart 1.2.0, this method should go in the //       ShapeUtilities class
// we'll have to use the method in the interface, but // this doesn't have the paint and stroke settings...
// FIXME: Check that there isn't already a series with the same key
// I know it's bad to create object. better idea?
// FIXME: clone generator
// TODO: use a generator here
// TODO: I think we need to make sure the keys are actually cloned, // whereas the paint instances are always immutable so they're OK
// FIXME: draw outliers
// TODO: I think we need to make sure the keys are actually cloned, // whereas the stroke instances are always immutable so they're OK
// not implemented
"/**     * Returns a string representing the week (e.g. ""Week 9, 2002"").     *     * TODO: look at internationalisation.     *     * @return A string representing the week.     */"
// FIXME: show a dialog with the error
// TODO: draw the interval marker with a 3D effect
// TODO: add serialization support for images
// could make this configurable
// TODO see if we need to apply some line color and style to the // axis traces
// FIXME:  implement this...
"/** * An annotation that allows an image to be placed at some location on * an {@link XYPlot}. * * TODO:  implement serialization properly (image is not serializable). */"
// if not, check if there is a paint defined for the specified key
// RANGE / RANGE
// height is OK, but width must be constrained
// do we need to fill the buffer?
// check that the clone doesn't share the same underlying arrays.
// now replacing the dataset should update the axis range...
// minorTickCount
// create a dataset...
// check that the renderer has a corresponding dataset (it doesn't // matter if the dataset is null)
// build first tab
/*Comparable k =*/
//row 2: background paint for the chart
// mercuryPaint
// period
// should get IllegalArgumentException for negative index
// create a legend, if requested...
// Segment fromSegment = getSegment(from); // fromSegment.inc(); // Segment toSegment = getSegment(to); // toSegment.dec();
// Dispose of any fonts we have created
// CASE 1 : Comparing to another TimeSeriesDataPair object // -------------------------------------------------------
//empty cell // row 2
// The following angle calc will ensure there isn't a top // vertical axis - this may be useful if you don't want any // given criteria to 'appear' move important than the // others.. //  + (getDirection().getFactor() //        * (cat + 0.5) * 360 / catCount);
// Create the color-change dialog
// draw the item labels if there are any...
// build second tab
// you can add a null list - it would have been better if this // required EMPTY_LIST
// row 4
// check if previously colinear
// set the plot properties...
// draw the standard deviation lines *before* the shapes (if they're // visible) - it looks better if the shape fill colour is different to // the line colour
//label.setFont(font);
// we create an event with a special flag set...the purpose of // this is to communicate to the plot (the default receiver of // the event) that series visibility has changed so the axis // ranges might need updating...
// don't need to do anything
// no need to instantiate this    
// row 1
// roseHighlightPaint
// return the appropriate axis editor
/* TimeSeriesDataItem item = */
// Create the new font and set it into the title // label
/* shape visible = */
// check a regular value
// test collection 3, which doesn't define all tasks in all series
/* XYSeries s = */
// row 3
// when the dataset contains one or more series, but those series  // contain no items, we expect the value range to be null
// Use a colored text field to show the color
//not first tick to be displayed //no tick label
// Create the font-change dialog
// in the following code, barL0 is (in Java2D coordinates) the LEFT // end of the bar for a horizontal bar chart, and the TOP end of the // bar for a vertical bar chart.  Whether this is the BASE of the bar // or not depends also on (a) whether the data value is 'negative' // relative to the base value and (b) whether or not the range axis is // inverted.  This only matters if/when we apply the minimumBarLength // attribute, because we should extend the non-base end of the bar
// Get the item count for the series, so that we can know which is the // end of the series.
//deal with range axis
/* shape filled = */
// set the range axis to display integers only...
// convert the font size (in pt for awt) to height in pixels for swt
// pass the click on to the plot... // rely on the plot to post a plot change event and redraw the chart...
// use item paint for outlines by // default, not outline paint
// handle the special case where the dataset has y-intervals that // we want to measure
/*CategoryPlot plot =*/
//deal with domain axis
// we're doing this for testing only, and make sure that we // only add data in ascending order by x-value
// verify max value
// change a series outline stroke
// verify min value
// check an inherited attribute
//gridBandPaint
// starts at the back, wraps around front, and // finishes at back again
//deal with plot appearance
// test a customised instance
// row 4: orientation
// rangeAxisLocation...
// row 2
// here we change the AffineTransform so we can draw the annotation // to a larger area and scale it down into the display area // afterwards, the original transform is restored
// row 3: background paint
// time zone
// row 1: stroke
// clip top and bottom bounds to data area
// check dataset with one time period
// BAR X
// we can't do anything
// sectionOutlinePaint
// we use ValueMarker for the tests, because we need a concrete // subclass...
// borderVisible
// to be consistent with other Graphics2D implementations
// validate base timeline exclusions added as timeline's esceptions
// domainAxisLocation - no longer a separate field but test anyway...
// row keys...
//private TickUnits standardTickUnits;
// backgroundImage
// try unknown column key
// minorTickLength
// when the dataset contains one or more series, but those series // contain no items, we still expect the range to be null
// labelFont
// TBLRC // 01010 - bottom and right only
// build the third tab
// do we need to resize the buffer?
// column keys...
// even though the axis is not visible, we need ticks for the // gridlines...
// ok and cancel buttons
// does nothing - override if necessary
// don't zoom unless the mouse pointer is in the plot's data area
// if there is a tool tip, we expect it to generate the title and // alt values, so we only add an empty alt if there is no tooltip
// borderStroke
// ensure we have a maximum value to use on the axes
// we dispose resources we own but user must dispose gc
// remove plot2, but plot1 is removed instead
// set the line style to solid by default
// we are starting a new series path
// apply dash style if any
// it is too slow to look at every data item, so let's just look at // the first, middle and last items...
//showing "1e#"-style ticks or negative exponent // generating tick value between 0 & 1; show fewer
//axisLabelPaint;
// properties // save // print // zoom // tooltips
// retrieve the swt font description in an os indept way
// collect entity and tool tip information...
// create a new awt font with the appropiate data
// and independent...
// for now we simply want to extract the chars from the iterator // and call an unstyled text renderer
// first get the range without the interval, then expand it for the // interval width
// see comment above //this.colorsPool.put(Integer.valueOf(awtColor.getRGB()), swtColor);
// renderingHints
// Next, setup the plot area
//this.myColor = new Color(getDisplay(), color.getRGB());
// seems to be the same...
// SWT and AWT share the same style constants.
// set the axis properties
// FIXME: add setBaseStroke(Stroke, boolean) ?
// create the dataset...
// null will be returned
// subtitles
// erase the previous zoom rectangle (if any).  We only need to do // this is we are using XOR mode, which we do when we're not using // the buffer (if there is a buffer, then at the end of this method we // just trigger a repaint)
// borderPaint
// draw the markers that are associated with a specific dataset...
// title
// start with a unit that is at least 1/10th of the axis length
// backgroundPaint
// adjust the plot area for interior spacing and labels...
// plot
// create the chart...
// add an item entity, if this information is being collected
// try a Double.POSITIVE_INFINITY
// Reference: http://www.antigrain.com/research/bezier_interpolation/
// pdfDocument class will be null so the function will return false
// as a special case, if the bar colour has alpha == 0, we draw // nothing.
//private double angle;
// avoid to draw overlapping tick labels
// check independence
// a null key should throw an IllegalArgumentException
// adding something to the returned list should NOT change the chart
//axis.setRangeType(RangeType.POSITIVE); //axis.setLowerBound(-5.0); //assertEquals(0.0, axis.getLowerBound(), EPSILON);
// perform the zoom on each range axis
// include legend
// draw the domain grid lines, if any...
// chart title
// check for bounds interval that includes 1
// outlinePaint
// deregister the collection as a change listener to each series in the // collection
//private Paint arrowPaint;
// value 1
// CASE 2 : Comparing to another TimePeriod object // -----------------------------------------------
// align this rectangle to the frameAnchor
// data // include legend // tooltips // urls
// standard test
// setup for collecting optional entity info...
//private NumberTickUnit tickUnit;
// do nothing if item is not visible
//drawingSupplier;
// get the previous point and the next point so we can calculate a // "hot spot" for the area (used by the chart entity)...
// use reflection to get the SVG string
//legendItemPaint;
// we suppress shadow generation, because SVG is a vector format and // the shadow effect is applied via bitmap effects...
// clear any exceptions in this timeline
// create array xIndex to hold // new column indices
// domainAxis...
// && state.getBarWidth() > BAR_OUTLINE_WIDTH_THRESHOLD) {
//wallPaint;
// selected rectangle shouldn't extend outside the data area...
// if the axes use a linear scale, you can uncomment the code below and // switch to the alternative transX/transY calculation inside the loop // that follows - it is a little bit faster then. // // int xx = (int) dataArea.getMinX(); // int ww = (int) dataArea.getWidth(); // int yy = (int) dataArea.getMaxY(); // int hh = (int) dataArea.getHeight(); // double domainMin = this.domainAxis.getLowerBound(); // double domainLength = this.domainAxis.getUpperBound() - domainMin; // double rangeMin = this.rangeAxis.getLowerBound(); // double rangeLength = this.rangeAxis.getUpperBound() - rangeMin;
// close
// reserve some space for the domain axis...
// seriesKey
// check that the listener lists are independent
//shadowPaint;
// reset the min and max
//private Stroke arrowStroke;
// return the override, if there is one...
//shadowVisible;
// bar is not visible
// actual value set below
//tickLabelPaint;
//parameter value is > 0 // The Math.log() function is based on e not 10.
//thermometerPaint;
// appendData() writes new data at the index position given by newestAt/ // When adding new data dynamically, use advanceTime(), followed by this:
// now try to reject equality...
//barPainter;
// if the axis is not visible, don't draw it...
//xyBarPainter;
// shadowXOffset
//errorIndicatorPaint;
// draw the plot (axes and data visualisation)
//if small log values and lower bound value too small // then set to a small value (don't allow <= 0):
// find optimum height
//private double tipRadius;
// add a second dataset, plotted against a second x axis
// Note that for consistency with the AWT implementation, it is // necessary to switch temporarily the foreground and background // colours
// work out if scaling is required...
//private double arrowLength;
// don't draw this tick label
//private double baseRadius;
// redraw the zoom rectangle (if present) - if useBuffer is false, // we use XOR so we can XOR the rectangle away again without redrawing // the chart
//private boolean autoRangeIncludesZero;
// set the outline paint to fully transparent, then the legend shape // will just have the same colour as the lines drawn by the renderer
// first field contains the row key
// weight
// TBLRC // 01001 - bottom and center only
// now map the dataset to the second xAxis
//g2.clip(clipArea);
// five dates to check...
/////////////////////////////////////////////////////////////////////////// // From IntervalXYDataset ///////////////////////////////////////////////////////////////////////////
//private double labelOffset;
//handle panning if we have a start point else unregister
/* BufferedImage image = */
// @mgs: using the method's return value was missing
// TBLRC // 10100 - top and left only
//get upper bound value
// value
// Unregister the collection as a change listener to each series in // the collection.
// stroke
// create the renderer...
// replace an existing series
// category
// add an entity for the item, but only if it falls within the // data area...
// categoryAnchor
// START: check d0 and d1
// tickMarkPosition
// test a default instance
// check that setting the min date to something on or after the // current min date works...
// offset the start of the boxes if the total width used is smaller // than the category width
// tickUnit
// draw the category labels and axis label
// timeline
//negative values are allowed //parameter value is > 10 // The Math.log() function is based on e not 10.
// range
// suppresses compiler warning
// CASE 1 : Comparing to another ComparableObjectItem object // ---------------------------------------------------------
// the following fields are inherited from the AbstractXYItemRenderer
// if the bug is still present, this leads to an endless loop
// TBLRC // 11000 - top and bottom only
// END: check d3 and d4
// MIDDLE: check d1, d2 and d3
// if this series belongs to a dataset, the dataset might veto the // change if it results in two series within the dataset having the // same key
/*JFreeChart chart =*/
// '+', remember value is negative
// an empty dataset should return a null range
// changing the item that was added should not change the series
// baseStroke
//end point is either lower left corner --> vertical gradient //or end point is upper right corner --> horizontal gradient
// argument checking delegated...
// try an empty dataset - should return a null range
// shapeLocation
// the row may not have an entry for this key, in which case the // return value is null
// test independence
// here we need to update the UI for the popup menu, if the panel // has one...
//private double arrowWidth;
// both axes
// END: check d0
// reserve space for the range axes (if any)...
// START: check d0
// CASE 3 : Comparing to a non-TimePeriod object // ---------------------------------------------
// fetch listeners from local storage
// case 1 - object is mutable but not PublicCloneable
// work out the space required by the domain axis...
// MIDDLE: check d0
// check retrieve value by key
// get desired width and height from somewhere then...
// no plot, no data
// Shifting with a delta of 0 does not change the range
// set axis bounds to be both greater than 1
/// Get the column names and cache them.
// check that changing a tick label font in a1 doesn't change a2
// check that changing a tick label paint in a1 doesn't change a2
// null dataset throws IllegalArgumentException
// check that changing a category label tooltip in a1 doesn't change a2
// if the popup menu has already been triggered, then ignore dragging...
// lowerMargin
// check for both bounds smaller than 1
// the line is visible - if it wasn't, we'd have // returned false from within the while loop above
// the CategoryDataset interface expects a list of series, but // we've stored them in an array...
// categoryMargin
// upperMargin
// Check if the item is the last item for the series. // and number of items > 0.  We can't draw an area for a single point.
// set start and end date
// TBLRC // 00101 - left and center items
// create the canvas and add the required listeners
// fillPaintList
////////////////////////////////////////////////////////////////////////// // test one-segment and adjacent segments //////////////////////////////////////////////////////////////////////////
// get the origin of the zoom selection in the Java2D space used for // drawing the chart (that is, before any scaling to fit the panel)
// if fixed auto range, then derive lower bound...
// set the new dataset, and register the chart as a change listener...
// advance line Stroke
// only draw if we have good values
// offset
// Check if the item is the last item for the series or if it // is a NULL value and number of items > 0.  We can't draw an area for // a single point.
// try a null key - should throw an exception
// compute common denominator
//private double fixedAutoRange;
// paint
// CASE 2 : Comparing to a general object // ---------------------------------------------
// tickLabelPaint
// register as a listener with sub-components...
// categoryLabelURLs
// draw domain crosshair if required...
// now draw annotations and render data items...
// tickLabelPaint2
// 4-ms test base timeline for ms2Timeline using 1 included and 1 // excluded segments // // timeline start time = 0 //   | //   v //   0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 ... // +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+... // |  |  |  |  |EE|EE|EE|EE|  |  |  |  |EE|EE|EE|EE|  |  |  |  |    <-- ms2BaseTimeline // +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+... //  \__________  _________/            \____  _____/ //             \/                           \/ //        segment group              segment size = 4 ms //
//private Shape leftArrow;
// verify attributes set during object construction
// after s1 is removed from the collection, we should be able to set // the key to anything we want...
// cycle bound mapping
// many of the zoom methods need a screen location - all we have is // the zoomPoint, but it might be null.  Here we grab the x and y // coordinates, or use defaults...
// ----------------------- // --- Private Methods --- // -----------------------
// make sure bins[bins.length]'s upper boundary ends at maximum // to avoid the rounding issue. the bins[0] lower boundary is // guaranteed start from min
// generic map for each series
// reduce the default margins
// advance line Visible
// for MacOSX we can't use the CTRL key for mouse drags, see: // http://developer.apple.com/qa/qa2004/qa1362.html
/* PUT exclusions in test */
// try a dataset with some content...
// Set start time
//lower bound and margin OK; get log10 of lower bound
// Create a segmented time line (segment size : 15 minutes)
// redrawing the chart every time...
/** These constants control test cycles in the validateXXXX methods. */
// make the chart area a square
/*Quarter q =*/
// make the background of the buffer clear and transparent
// add minor ticks (for gridlines)
// a Double.NaN should be ignored
// calculate 9am on the first Monday after 2001-01-01
// default instances
// low
// calculate the max label width from the plot dimensions, because // a circular pie can leave a lot more room for labels...
// the anchor point is typically the point where the mouse last // clicked - the crosshairs will be driven off this point...
// if there is an explicit mapping to the default group, it is counted
// test 9am-4pm Monday through Friday timeline
// the segment is entirely at the // front of the chart
// RANGE / NONE
// test some included and excluded segments
//// STROKE ///////////////////////////////////////////////////////////////
// TBLRC // 01000 - bottom item only
// zap the buffer onto the panel...
// logically consecutive segments non-physically consecutive // (with non-contained time in between)
// POSITIVE ITEM LABEL POSITION
// verify segments are consecutive and correct
// get the data point...
// test inc() method
// we create a new but empty chartMouseListeners list
// visible flag...
//dmo: (end dmo additions)
// try next segment
// itemLabelsVisible
// exclude current exception and last one
////////////////////////////////////////////////////////////////////////// // test inc methods //////////////////////////////////////////////////////////////////////////
// check that the series visible flag is observed
// go to another segment to continue test
// no data in the parent plot
// make the link area a square if the pie chart is to be circular... // is circular?
// test inc(n) method
// fixed domain axis space...
// select a tick unit that is the next one bigger than the current // (log) range divided by 50
// font
// tick label insets...
// the link area defines the dog leg points for the linking lines to // the labels
// verify list of exceptions
// lowerBound
// tick labels visible flag...
// fill in the exceptions
// rangeAxisLocation - no longer a separate field but test anyway...
// should be an excluded segment
// add an entity for the item, but only if it falls within the data // area...
// should be an included segment
// include current exception and last one
// tick mark paint...
// we need to guard against this.zoomPoint being null
//long v = stl.toTimelineValue(946684800020L);
// strokeList
// tickLabelOffset
// if multiple axes are mapped, the first in the list should be // returned...
// only add an exception if it is currently an included segment
// consider time periods to be ordered after general objects
// add our exceptions and store locally in ArrayList of Longs
// private Plot parent <-- don't clone the parent plot, but take care // childs in combined plots instead
// some checks that the clone is independent of the original
// make array of exceptions
// if the dataset is not a StatisticalCategoryDataset then just revert // to the superclass (LineAndShapeRenderer) behaviour...
// start time...
// try replacing an existing value
// add the base timeline exclusions as timeline's esceptions
// adjust the plot area by the interior spacing value
// 1-Jan-2000
//  Remove series 2 and add new series
// subLabelPaint
// ****************************************************************** //  More than 150 demo applications are included with the JFreeChart //  Developer Guide...for more information, see: // //  >   http://www.object-refinery.com/jfreechart/guide.html // // ******************************************************************
// by default, the renderer with index 0 is used
// ensure the autorange is at least <minRange> in size...
////////////////////////////////////////////////////////////////////////// // test serialization //////////////////////////////////////////////////////////////////////////
// set up info collection...
// subLabelFont
// this replaces the entry with the current minimum value, but the new // minimum value is now in a different item
// verify all timeline segments included in the // baseTimeline.segment are now exceptions
// ********* stat function for linear slope ******** // y = a + bx // a = ybar - b * xbar //     sum(x * y) - (sum (x) * sum(y)) / n // b = ------------------------------------ //     sum (x^2) - (sum(x)^2 / n // *************************************************
// subcategories
////////////////////////////////////////////////////////////////////////// // utility methods //////////////////////////////////////////////////////////////////////////
// physically consecutive
// hasn't implemented DomainInfo, so iterate...
// if there is no separator, we assume the first four characters // are YYYY
// label font...
// adjust the drawing area for the plot insets (if any)...
// label...
// pre-fetch the colors for each key...this is because the subplots // may not display every key, but we need the coloring to be // consistent...
// label paint...
// holds the moving average sum
// attributed label...
// now add some more data
// label insets...
// if the box has been drawn backwards, restore the auto bounds
// high
"/*                 * Lots can go wrong while fiddling with Images, Color Models                 * & such!  If anything at all goes awry, just return the original                 * TexturePaint.  (TexturePaint's are immutable anyway, so no harm                 * done)                 */"
// axis line stroke...
// Add each point to Area (x, y)
// label angle...
// if the axis is not visible, no additional space is required...
// axis line visible...
// NONE / FIXED
// TBLRC // 10001 - top and center only
// axis line visible flag...
"/* =========================================================== * JFreeChart : a free chart library for the Java(tm) platform * =========================================================== * * (C) Copyright 2000-2014, by Object Refinery Limited and Contributors. * * Project Info:  http://www.jfree.org/jfreechart/index.html * * This library is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as published by * the Free Software Foundation; either version 2.1 of the License, or * (at your option) any later version. * * This library is distributed in the hope that it will be useful, but * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public * License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this library; if not, write to the Free Software * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, * USA. * * [Oracle and Java are registered trademarks of Oracle and/or its affiliates.  * Other names may be trademarks of their respective owners.] * * ----------------- * ChartFactory.java * ----------------- * (C) Copyright 2001-2014, by Object Refinery Limited and Contributors. * * Original Author:  David Gilbert (for Object Refinery Limited); * Contributor(s):   Serge V. Grachov; *                   Joao Guilherme Del Valle; *                   Bill Kelemen; *                   Jon Iles; *                   Jelai Wang; *                   Richard Atkinson; *                   David Browning (for Australian Institute of Marine *                       Science); *                   Benoit Xhenseval; * * Changes * ------- * 19-Oct-2001 : Version 1, most methods transferred from JFreeChart.java (DG); * 22-Oct-2001 : Added methods to create stacked bar charts (DG); *               Renamed DataSource.java --> Dataset.java etc. (DG); * 31-Oct-2001 : Added 3D-effect vertical bar and stacked-bar charts, *               contributed by Serge V. Grachov (DG); * 07-Nov-2001 : Added a flag to control whether or not a legend is added to *               the chart (DG); * 17-Nov-2001 : For pie chart, changed dataset from CategoryDataset to *               PieDataset (DG); * 30-Nov-2001 : Removed try/catch handlers from chart creation, as the *               exception are now RuntimeExceptions, as suggested by Joao *               Guilherme Del Valle (DG); * 06-Dec-2001 : Added createCombinableXXXXXCharts methods (BK); * 12-Dec-2001 : Added createCandlestickChart() method (DG); * 13-Dec-2001 : Updated methods for charts with new renderers (DG); * 08-Jan-2002 : Added import for *               com.jrefinery.chart.combination.CombinedChart (DG); * 31-Jan-2002 : Changed the createCombinableVerticalXYBarChart() method to use *               renderer (DG); * 06-Feb-2002 : Added new method createWindPlot() (DG); * 23-Apr-2002 : Updates to the chart and plot constructor API (DG); * 21-May-2002 : Added new method createAreaChart() (JI); * 06-Jun-2002 : Added new method createGanttChart() (DG); * 11-Jun-2002 : Renamed createHorizontalStackedBarChart() *               --> createStackedHorizontalBarChart() for consistency (DG); * 06-Aug-2002 : Updated Javadoc comments (DG); * 21-Aug-2002 : Added createPieChart(CategoryDataset) method (DG); * 02-Oct-2002 : Fixed errors reported by Checkstyle (DG); * 09-Oct-2002 : Added methods including tooltips and URL flags (DG); * 06-Nov-2002 : Moved renderers into a separate package (DG); * 18-Nov-2002 : Changed CategoryDataset to TableDataset (DG); * 21-Mar-2003 : Incorporated HorizontalCategoryAxis3D, see bug id 685501 (DG); * 13-May-2003 : Merged some horizontal and vertical methods (DG); * 24-May-2003 : Added support for timeline in createHighLowChart (BK); * 07-Jul-2003 : Added createHistogram() method contributed by Jelai Wang (DG); * 27-Jul-2003 : Added createStackedAreaXYChart() method (RA); * 05-Aug-2003 : added new method createBoxAndWhiskerChart (DB); * 08-Sep-2003 : Changed ValueAxis API (DG); * 07-Oct-2003 : Added stepped area XY chart contributed by Matthias Rose (DG); * 06-Nov-2003 : Added createWaterfallChart() method (DG); * 20-Nov-2003 : Set rendering order for 3D bar charts to fix overlapping *               problems (DG); * 25-Nov-2003 : Added createWaferMapChart() method (DG); * 23-Dec-2003 : Renamed createPie3DChart() --> createPieChart3D for *               consistency (DG); * 20-Jan-2004 : Added createPolarChart() method (DG); * 28-Jan-2004 : Fixed bug (882890) with axis range in *               createStackedXYAreaChart() method (DG); * 25-Feb-2004 : Renamed XYToolTipGenerator --> XYItemLabelGenerator (DG); * 11-Mar-2004 : Updated for pie chart changes (DG); * 27-Apr-2004 : Added new createPieChart() method contributed by Benoit *               Xhenseval (see RFE 942195) (DG); * 11-May-2004 : Split StandardCategoryItemLabelGenerator *               --> StandardCategoryToolTipGenerator and *               StandardCategoryLabelGenerator (DG); * 06-Jan-2005 : Removed deprecated methods (DG); * 27-Jan-2005 : Added new constructor to LineAndShapeRenderer (DG); * 28-Feb-2005 : Added docs to createBubbleChart() method (DG); * 17-Mar-2005 : Added createRingPlot() method (DG); * 21-Apr-2005 : Replaced Insets with RectangleInsets (DG); * 29-Nov-2005 : Removed signal chart (DG); * ------------- JFREECHART 1.0.x --------------------------------------------- * 26-Jan-2006 : Corrected API docs for createScatterPlot() (DG); * 23-Aug-2006 : Modified createStackedXYAreaChart() to use *               StackedXYAreaRenderer2, because StackedXYAreaRenderer doesn't *               handle negative values (DG); * 27-Sep-2006 : Update createPieChart() method for deprecated code (DG); * 29-Nov-2006 : Update createXYBarChart() to use a time based tool tip *               generator is a DateAxis is requested (DG); * 17-Jan-2007 : Added createBoxAndWhiskerChart() method from patch 1603937 *               submitted by Darren Jung (DG); * 10-Jul-2007 : Added new methods to create pie charts with locale for *               section label and tool tip formatting (DG); * 14-Aug-2008 : Added ChartTheme facility (DG); * 23-Oct-2008 : Check for legacy theme in setChartTheme() and reset default *               bar painters (DG); * 20-Dec-2008 : In createStackedAreaChart(), set category margin to 0.0 (DG); * 02-Jul-2013 : Use ParamChecks class (DG); *  */"
// label location...
// tick label paint...
// go through each zoom menu item and decide whether or not to // enable it...
// tick mark inside length...
// if the source point doesn't fall within a subplot, we do the // zoom on all subplots...
// fixed dimension...
// tick mark outside length...
// NONE / RANGE
//get absolute value of log10 value
//private Shape downArrow;
//upper bound and margin OK; get log10 of upper bound
//private Shape rightArrow;
// add a second renderer with the same index as dataset2, now it will // be used
//private Shape upArrow;
// NONE / NONE
// in the rendering process, there is special handling for item // zero, so we can't support processing of visible data items only
// verticalTickLabels
// update (x1, y1), (x2, y2) and f1 and f2 using intersections // then recheck
// axisLineStroke
// yearFormatter
// check arguments...
// locale
// if series are in columns, then the categories are the row keys
// showYear[]
// when the dataset contains no series, we expect the range to be null
// chars
// now repeat for a vertical axis
// FIXED / RANGE
// draw the annotations (if any)...
//end point is lower right corner --> diagonal gradient
// The next 3 functions implement the RangeInfo interface. // Using saved limits (updated by each updateTime() call) significantly // improves performance.  WARNING: this code makes the simplifying // assumption that data is never negative.  Expand as needed for the // general case.
// FIXED / NONE
// RANGE / FIXED
////////////////////////////////////////////////////////////////////////// // main include and excluded segments //////////////////////////////////////////////////////////////////////////
// TBLRC // 00100 - left item only
// this is the last period, but it is only partially visible // so check that the label will fit before displaying it...
// TBLRC // 00010 - right item only
// check that there is some data to display...
// FIXED / FIXED
// CASE 1 : Comparing to another TimeSeriesDataItem object // -------------------------------------------------------
// TBLRC // 10111
//only 1 power of 10 value, it's > 0 and its resulting // tick value will be larger than lower bound of data //decrement to generate more ticks
// draw the block without collecting entities
// try case where right item is shorter than center item
// initialize ChartPanel-specific tool tip delays with // values the from ToolTipManager.sharedInstance()
// should be 2 items
// if the incoming state is null, no information will be passed // back to the caller - but we create a temporary state to record // the plot area, since that is used later by the axes
// TBLRC // 00011 - right and center items
// check if this addition will exceed the maximum item count...
// try case where left item is shorter than center item
// here we check that the average marker will in fact be // visible before drawing it...
// TBLRC // 10110 - top, left and right
// check a series with one item
// if we've been panning, we need to reset now that the mouse is  // released...
// TBLRC // 00110 - left and right items
// add an entity for the item...
// otherwise look up the generator table
// TBLRC // 00111 - left, right and center items
// try an array containing a single Number and a null
// CASE 1 : Comparing to another Minute object // -------------------------------------------
// TBLRC // 11100
// TBLRC // 11001
// add a value that isn't in the xRange
// TBLRC // 11111 - all
// a Collection containing a NaN will return Double.NaN for the result
// TBLRC // 11110
// special case - if the underlying rectangle uses ints we // need to create one that uses doubles
// create dataset 1...
// set up popup menu...
// no need to create entity if we can't save it anyways...
// erase the zoom rectangle
// secondary DatasetDomainAxisMap...
// test a series with 1 item
// if the initial averaging period is to be excluded, then // calculate the lowest x-value to have an average calculated...
// TBLRC // 11010 - top, bottom and right
// TBLRC // 01100
// initialize the members of "seriesNames" array so they won't be null:
// remove a value
// wrong outcome
// TBLRC // 01011 - bottom, right and center
// change rendering order to ensure that bar overlapping is the // right way around
// check that removing by index also works
// no additional methods required
// now we should be allowed to change s1's key to anything but "S2"
// standard case - plain XYDataset
// either autoWidth is off or autoIntervalWidth was not set.
//dmo: added this panel for colorbar control. (start dmo additions)
// TBLRC // 10011 - top, right and center
// TBLRC // 01110 - bottom. left and right
// TBLRC // 01101 - bottom, left and center
// TBLRC // 10000 - top item only
// check that the new bin doesn't overlap with any existing bin
// TBLRC // 10010 - right and top only
// TBLRC // 11011
// defer null argument check
// some setup...
// do nothing if item is not visible or null
// Y format
// handle three cases by dataset type
// tooltip format
"/* // ""Extras"" found useful when analyzing/verifying class behavior:    public Number getUntranslatedXValue(int series, int item)    {      return super.getXValue(series, item);    }    public float getUntranslatedY(int series, int item)    {      return super.getY(series, item);    }  */"
// date format
//  If data can be < 0, the next 2 methods should be modified
// create subplot 1...
//  Create new dataset with keys above threshold percentThreshold
// try a null value
// now extrapolate based on label height and unit height...
// another test...
// end period is not in original series // this is first item AFTER end period // so this is last item BEFORE end
// the reverse transformed value will be in the start of the // next non-excluded and non-exception segment
// x number format
// format string...
// Add last point @ y=0 for fillPath and close path
// x date format
// y number format
// orientation...
/////////////////////////////////////////////////////////////////////////// // From SeriesDataset ///////////////////////////////////////////////////////////////////////////
// create subplot 2...
//yAdj = -descent - leading + (float) bounds.getHeight();
// add the subplots...
// the actual panning occurs later in the mouseDragged()  // method
// separatorPaint
//apply upper margin by increasing upper bound:
// now get the data and plot it (the visual representation will depend // on the m_Renderer that has been set)...
// for item labels, we have a special case because there is the // possibility to draw (a) the regular item label near to just the // upper y-value, or (b) the regular item label near the upper y-value // PLUS an additional item label near the lower y-value.
// axisOffset...
// Absolute value, since the relative x // positions are reversed for horizontal orientation
// TBLRC // 00000 - no items
// request with a negative index
// try negative row index
// domainAxes...
// work out the number of periods to skip for labelling
//////////////////////////////////////////////////////////////////////////// // private attributes ////////////////////////////////////////////////////////////////////////////
//turn off anti-aliasing when filling rectangles
// draw shared domain axis...
// TBLRC // 11101
// check handling when the dataset is a regular XYDataset, not an // XYZDataset...
// get the previous data point...
// rendering order...
// calculate the data area...
// domainAxisLocations...
// CASE 2 - object is mutable AND PublicCloneable
// try a default instance
// renderers...
// forces recalculation of the axis range
// closeTickPaint
// rangeAxes...
// fake a dataset change event to update axes...
// rangeAxisLocations...
// get a list of keys...
//first tick of group; create label text
// annotations
// handle panning if we have a start point
// draw the arrow...
// is there an alignment adjustment to be made?
// rangeGridlinePaint
// Generate the grid
// delegate argument checking to XYDataItem...
// rangeGridlineStroke
"/* From outlier array sort out which are outliers and put these into         * an arraylist. If there are any farouts, set the flag on the         * OutlierListCollection         */"
/* Rectangle2D hotspot = */
// rowRenderingOrder...
// a key that hasn't been mapped should return the default group
// background range markers...
// this should never happen with the existing code, but throw // an exception in case future changes make it possible...
// rangeCrosshairValue
// default is to notify listeners when the // chart changes
//parameter value is < -10 //calculate log using positive value:
// starts at the front, finishes at the back (going // around the left side)
// labelGenerator
"/*         * we assum super is always initialized to all-zero matrix, so the         * total sum should be 0 upon initialization. However, we set it to         * Double.MIN_VALUE to get the same effect and yet avoid division by 0         * upon initialization.         */"
// starts at back, finishes at front (CLOCKWISE)
// background domain markers
// override default
// foreground range markers...
// special case where the lowest x-value is >= xLow
// foreground domain markers
// make sure there are no exceptions
//return toTimelineValue(dateDomainValue.getTime());
//calculate power using positive value; then negate
// create a new space object if one wasn't supplied...
// check for independence
// define the default locations for up to 8 axes...
//// SERIES OUTLINE PAINT ////////////////////////////
// fixed range axis space...
// send a dataset change event to self...
// shadowGenerator
// axis line paint...
// try a dataset with a single value
//parameter value is <= 0 //use as-is
// we didn't get an exception so all is good
// the x value is not within the axis range
// correct outcome
// should be equal...
// dial outline paint
// add a second dataset
// get the current data item...
// check second argument less than first argument
// labelPaint
// check index == getItemCount() throws exception
// we should be able to give a dataset an arbitrary index
// if the plot area is too small, just return...
// Set XOR mode to draw the zoom rectangle
// we should be able to give a renderer an arbitrary index
// outline paint
// domainGridlinePaint
// are we using the chart buffer?
// draw average - SPECIAL AIMS REQUIREMENT
// toolTipGenerator
// adjust the drawing area for plot insets (if any)...
// drawBorder
// can we pan this plot?
// tick label paint
// force a redraw // new entity code...
// update the linking line target for later // add an entity for the pie section
// XYDataset only provides methods for reading a dataset...
// tick label font
// remove the point i-periodCount out of the rolling sum.
// value paint
// check if there are any values earlier than specified by the history // count...
// value font
// set up some objects...
// needle paint
// set a theme using the new shadow generator feature available in // 1.0.14 - for backwards compatibility it is not enabled by default
//stroke
// Draw the new zoom rectangle...
// tick label format
// setTickValues was missing from ColorPalette v. 0.96 //colorPalette.setTickValues(this.axis.getTicks());
//alpha
// draw border
// since the items are ordered, we could be more clever here and avoid // iterating over all the data
//paint
// as a class variable, initializes == 0
// tick paint
// meter angle
// add the subtrahend's points to the polygon in reverse
//key
// stop listening for changes to the existing chart
/// we have rotation
//get positive exponent //create multiplier value //multiply, round up, and divide for bound value:
// change the generator and make sure it only affects p1
//outlineStroke
// secondary RangeAxes...
// draw the axis label (note that 'state' is passed in *and* // returned)...
// roseCenterPaint
// create the plot...
// rosePaint
// first determine the size of the chart rendering area...
// Reset to the default 'overwrite' mode
// interiorGap
// interiorGap...
// extent
// labelGap
// sectionPaint
// additional dataArea modifications //check whether modification is
// circular
// another empty series
// ignoreNullValues
// direction
// now get the data and plot it (the visual representation will depend // on the renderer that has been set)...
// sectionPaintMap
/////////////////////////////////////////////////////////////////////////// // New Methods ///////////////////////////////////////////////////////////////////////////
// when the dataset contains no series, we expect the value range to  // be null
// labelOutlineStroke
// separatorsVisible
// super.drawSecondaryPass(g2, plot, dataset, pass, series, item, // domainAxis, dataArea, rangeAxis, crosshairState, entities);
// labelOutlinePaint
// shadowPaint
// newestAt takes value previously held // by oldestAT
// shadowYOffset
// outlineVisible
//get log10 version of lower bound and round to integer:
// try a customised instance
// links visible
// verify various indices inside a segment are the same segment
// maximumLabelWidth
// explodePercentages
"/* (non-Javadoc)         * @see org.jfree.chart.axis.LogarithmicAxis#switchedLog10(double)         */"
// labelShadowPaint
// we suppress shadow generation, because PDF is a vector format and // the shadow effect is applied via bitmap effects...
// handle transparency and compositing.
// startAngle
// a list to store the series index and bar region, so we can draw // all the labels at the end...
// get the relevant source coordinate given the plot orientation
// store the current time zone
// axisLinePaint
// previous data point...
// check that the URL generator has been cloned
// The following alternative is only supported in JDK 1.4 - we support // JDK 1.3.1 onwards // setItemLabelsVisible(Boolean.valueOf(visible));
// urlGenerator
// linkMargin
// Process outliers. Each outlier is either added to the // appropriate outlier list or a new outlier list is made
// labelLinkStroke
// only needed if calculating percentages
// legendItemShape
// offset the start of the box if the box width is smaller than the // category width
// long result = calendar.getTimeInMillis(); // won't work with JDK 1.3
// the clone references the same dataset as the original
// plot is likely registered as a listener with the existing axis...
// check that zero items are ignored if requested
// get two consecutive segments for various tests
// outlineStroke
// submit the current data point as a crosshair candidate
// check that null items are ignored if requested
// we can't use the following valueOf() method, because it // won't compile with JDK1.4 // this.colorsPool.get(Integer.valueOf(awtColor.getRGB()));
// this should have been defined as a boolean primitive, because // allowing null values is a nuisance...but it is part of the final // API now, so we'll have to support it.
// change the shape and make sure it only affects p1
// we don't know anything about the ordering of the x-values, // but we can still skip any initial values that fall outside the // range...
// check that negative items are always ignored
// draw the item label if there is one...
// noDataMessagePaint
// FIXME: add setBaseToolTipGenerator(CategoryToolTipGenerator, boolean) ?
// noDataMessageFont
// noDataMessage
// de-register the composite as a listener for the chart.
// try a null collection
// foregroundAlpha
// draw the top axes
// drawingSupplier
// NOW DO SOME OPTIONAL CUSTOMISATION OF THE CHART...
// backgroundAlpha
// secondary renderers
// row 1: antialiasing
// dataExtractOrder
// maxValue
// title // x-axis label // y-axis label // data // create legend? // generate tooltips? // generate URLs?
// valueFont
// if a subtrahend is not specified, assume it is zero
// key not found
// if we get to here, we know that duplicate X values are not permitted
// polygon definitions
// since the flow layout is relatively straightforward, // no information needs to be recorded here
// draw the label
// copy a range before the start of the series data...
// add another value
// change a series paint
// add a second dataset, plotted against a second axis
// no event is generated if the dataset is already empty
// axisLabelGap
// Performs the actual drawing here ...
// secondary DomainAxisLocations...
// if there is an existing dataset, remove the plot from the list of // change listeners...
// webFilled
// check that super class fields are being looked at...
// change the legendItemShape
// axisIndices can be: // 1.  null; // 2.  non-empty, containing only Integer objects that are unique.
// thermometerPaint
// valueLocation
// now add a third value to the series...
// as far as I know, the Locale for the calendar only affects week // number calculations, and since DateTickUnit doesn't do week // arithmetic, the default locale (whatever it is) should be fine // here...
//first tick of group // did not do zero tick last // iteration
// domainAxisLocation...
// delegate 'info' and 'source' argument checks...
// loop over intervals between nodes
// valueFormat
// valuePaint
// dataset index
// axisLocation
// thermometerStroke
// this doesn't work
// check if starting new column
// secondary RangeAxisLocations...
// secondary DomainAxes...
// rangeAxis...
// renderer
// change a series outline paint
// for mouseReleased event, (horizontalZoom || verticalZoom) // will be true, so we can just test for either being false; // otherwise both are true
// parent plot...
// itemLabelFontList
//outlinePaint
// try a collection with a single number plus a null
// restore original tooltip dealys
// z number format
// data
// do we need to redraw the buffer?
// locale should not matter here
// since this is only used by clearRect(), we don't update the GC yet
// when the x-values are sorted in descending order, the lower // bound is found by calculating relative to the xHigh value
// fixed legend items
// relay the event from the canvas to our registered listeners
// use item paint for fills by default
// BarRenderer
// textAnchor
// create storage for listeners...
// tickLabelFont
// last item in series, draw the lot... // set up the alpha-transparency...
//int midY = (int) (plotArea.getMinY() + (plotArea.getHeight() / 2));
//tick value not between 0 & 1 //show tick label if it's the first or last in // the set, or if it's 1-5; beyond that show // fewer as the values get larger:
// TBLRC // 10101 - top, left and center
// We organise the data with the following assumption: // 1) the data are sorted by x then y // 2) that the data will be represented by a rectangle formed by //    using x[i+1], x, y[j+1], and y. // 3) we march along the y-axis at the same value of x until a new //    value x is found at which point we will flag the index //    where x[i+1]<>x[i]
// 2. check whether the column is now empty.
// adjust for insets...
// can't allow duplicate values, so we need to check whether // there is an item with the given x-value already
// no renderer 1
//private NumberFormat numberFormatOverride;
// OUTLINE STROKE
// quadrant paint
// create the polygon // add the minuend's points to polygon
// return the generator for ALL series, if there is one...
// paint sequence
/////////////////////////////////////////////////////////////////////////// // From XYDataset ///////////////////////////////////////////////////////////////////////////
// draw the tick marks and labels...
// now test that the clone is independent of the original
// shape sequence
// outline stroke sequence
// for a series with no data, we expect {-1, -1}...
// outline paint sequence
// 'baseItemLabelPaint' : immutable, no need to clone reference
// now overwrite this item with another
// create dataset 2...
// setup our test timelines // // Legend for comments below: // <spaces> = Segments included in the final timeline // EE       = Excluded segments via timeline rules // xx       = Exception segments inherited from base timeline exclusions
// gradient paint transformer
// paint index
/* ComparableObjectItem item1 = */
// in this case, every color has a range of values
// with no buffer, we use XOR to draw the rectangle "over" the // chart...
// only relevant when this is a subplot
// create an array of items in reverse order
// upperBound
// compute common deltas
// tickRadius
// clear the flag
// nothing is drawn if the row index is not included in the list with // the indices of the visible rows...
// radius
// try a few checks to ensure that the clone is independent of the // original
// check the case where there is a secondary dataset that doesn't // have a renderer (i.e. falls back to renderer 0)
// verify that the plot is listening to the cloned renderer
// check key order
// shape index
// draw median
// now try to reject equality
// check negative index throws exception
// outline stroke index
// we don't know anything about the ordering of the x-values, // so we iterate until we find the first crossing of x (if any) // we know there are at least 2 items in the series at this point
// now remove a3, but since a3.equals(a1), this will in fact remove // a1...
// add a value to the second series
// actually removes a1
// check that the generator has been cloned
// check for unknown column
//// SECTION OUTLINE PAINT ////////////////////////////////////////////////
// if there are only null items, we get a NaNRange
// copy the middle three items...
// visible
// shape
// check that empty dataset is handled OK
// continue and separate the labels only if necessary
// set up the category names...
// dateFormatOverride
//negative values not allowed //parameter value is > 0 // The Math.log() function is based on e not 10.
// a column of all null values is still counted...
// outer radius
// first arrange without constraints, then see if the width fits // within the required range...if not, call arrangeFN() at max width
// now when the default group is mapped to, it shouldn't increase the // group count...
// foregroundPaint
// The split may occur in either x splitted segments, if any, but // not in both
// inner radius
//////////////////////////////////////////////////////////////////////////// // constructors and factory methods ////////////////////////////////////////////////////////////////////////////
// foreground paint
// tick mark stroke...
// confirm overwriting an existing value
// frameAnchor
// angle
// 'negativeItemLabelAnchor' : immutable, no need to clone reference
// clear a mapping
// test a custom instance
// templateValue
// outline stroke
// fill paint
// check retrieve value by index
// valueAnchor
// not a HighLowDataset, so just draw a line connecting this point // with the previous point...
// dial cap
// now make a change to the renderer and see if it triggers a plot // change event...
// not first or last tick on graph and value // is 1.0 //change value to 0.0 //indicate zero tick //create label for tick
//get the coordinates of the original GradientPaint
// frame
// negative paint
// view
// if negative then set flag and make positive
// layer
// populate deprecated fields
// check that a null dataset returns null bounds
// standard ResourceBundle behaviour
// apply the margins - these should apply to the exponent range
//    /** Insets text field. */ //    private InsetsTextField tickLabelInsetsTextField; // //    /** Label insets text field. */ //    private InsetsTextField labelInsetsTextField;
// check a series with four items
// outlineStrokeList
// majorTickLength
//cursor = midX - COLUMN_RADIUS - AXIS_GAP;
// sometimes the last few days of the year are considered to fall in // the *first* week of the following year.  Refer to the Javadocs for // GregorianCalendar.
// majorTickStroke
// 'baseOutlinePaint' : immutable, no need to clone reference
// try a null dataset - should return a null range
// majorTickIncrement
// Add the last point (x,0)
// majorTickPaint
// the noCodeBaseClassLoader is configured by a call to the // removeCodeBase() method, typically in the init() method of an // applet...
// label
// outline paint index
// seriesVisible
// baseSeriesVisible
// second pass adds shapes where the items are ..
// have to use a concrete subclass...
//parameter value is > 10 // The Math.log() function is based on e not 10.
// cycle through all the segments contained in the BaseTimeline // exception segment
// can't find any differences
// test default instance
// -------------------- // --- Constructors --- // --------------------
// seriesVisibleList
// adjust for padding...
// outlinePaintList
// get the axis label size and update the space object...
// check that setting the max date to something on or before the // current min date works...
// work out the anchor point
// baseFillPaint
// just the lines, no filling
// baseShape
// check a series with two items
//small log values in use; create numeric value for tick
// createEntitiesList;
// If the segment must be splitted, insert a new point // Strict test forces to have real segments (not 2 equal points) // and avoids division by 0
// complicate things a little...
// customise the title position and font
// shapeList
// baseOutlineStroke
// add the new chart
// seem to be the same...
// draw the plot background and axes...
// slope
// no renderer, no gridlines...
// itemLabelPaint
// while the tick labels overlap and there are more tick sizes available, // choose the next bigger label
// ...but this does!
// this is not one of our included segment, skip it
// baseItemLabelFont
// work out the value, label and position
// itemLabelFont
// draw the lower shadow...
// itemLabelPaintList
// calculate the bar width - this calculation differs from the // BarRenderer calculation because the bars are layered on top of one // another, so there is effectively only one bar per category for // the purpose of the bar width calculation
// sanity check for data area...
// createEntities;
/* y-axis label */
// baseItemLabelPaint
// if no initial zoom point was set, ignore dragging...
// SHAPE
// baseOutlinePaint
// insets
// now check autoPopulate==true
// baseLegendShape
// ITEM_LABELS_VISIBLE
// legendShape
// legendTextFont
// OUTLINE PAINT
// baseLegendTextFont
// ITEM_LABEL_FONT
// failed
// NEGATIVE ITEM LABEL ANCHOR
// check a series with no items
// now remove series 2 from collection 2
// first test for equality (contains or contained)
// add series to collection 1, should be not equal
// it is unlikely that 'state' will be null, but check anyway...
// check a series with repeating items
// check a series with three items
// check dataset with two time periods
//private Paint negativeBarPaint;
// we're doing this for testing only, and make sure that we // only add data in descending order by x-value
// try with gradient paint
// drawYError
// positiveBarPaint;
// Compute number of labels
// lastBarPaint;
// firstBarPaint;
// the renderer should not be equal to a BarRenderer
// quick check for independence
// TOP
// set flag true if negative values not allowed and the // lower bound is between 0 and 10:
// what is our alignment?
// urlGeneratorList
// RIGHT
// drawBarOutline
// autoWidthFactor
// itemMargin
// try something from the base class
// base value
// minimumBarLength
// maximumBarWidth
// barPainter
// shadowsVisible
// try null argument
// setUseYInterval
// try empty dataset
// setDrawBarOutline()
// setBase()
// legendBar
// setMargin()
// check a list containing a non-Number object
// autoWidthMethod
// drawOpenTicks
// roundXCoordinates
// legendLine
// drawXError
// drawCloseTicks
// openTickPaint
// tickLength
// candleWidth
// drawVolume
// first arrange without constraints, and see if this fits within // the required ranges...
// downPaint
// upPaint
// check boxPaint null also
// find out where to place the label...
// linePaint
// fillPaint
// make sure that modifying the returned array doesn't change the // function
// stripOutlineVisible
"/* =========================================================== * JFreeChart : a free chart library for the Java(tm) platform * =========================================================== * * (C) Copyright 2000-2013, by Object Refinery Limited and Contributors. * * Project Info:  http://www.jfree.org/jfreechart/index.html * * This library is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as published by * the Free Software Foundation; either version 2.1 of the License, or * (at your option) any later version. * * This library is distributed in the hope that it will be useful, but * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public * License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this library; if not, write to the Free Software * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, * USA. * * [Oracle and Java are registered trademarks of Oracle and/or its affiliates.  * Other names may be trademarks of their respective owners.] * * ------------------- * ChartUtilities.java * ------------------- * (C) Copyright 2001-2013, by Object Refinery Limited and Contributors. * * Original Author:  David Gilbert (for Object Refinery Limited); * Contributor(s):   Wolfgang Irler; *                   Richard Atkinson; *                   Xavier Poinsard; * * Changes * ------- * 11-Dec-2001 : Version 1.  The JPEG method comes from Wolfgang Irler's *               JFreeChartServletDemo class (DG); * 23-Jan-2002 : Changed saveChartAsXXX() methods to pass IOExceptions back to *               caller (DG); * 26-Jun-2002 : Added image map methods (DG); * 05-Aug-2002 : Added writeBufferedImage methods *               Modified writeImageMap method to support flexible image *               maps (RA); * 26-Aug-2002 : Added saveChartAsJPEG and writeChartAsJPEG methods with info *               objects (RA); * 05-Sep-2002 : Added writeImageMap() method to support OverLIB *               - http://www.bosrup.com/web/overlib (RA); * 26-Sep-2002 : Fixed errors reported by Checkstyle (DG); * 17-Oct-2002 : Exposed JPEG quality setting and PNG compression level as *               parameters (DG); * 25-Oct-2002 : Fixed writeChartAsJPEG() empty method bug (DG); * 13-Mar-2003 : Updated writeImageMap method as suggested by Xavier Poinsard *               (see Feature Request 688079) (DG); * 12-Aug-2003 : Added support for custom image maps using *               ToolTipTagFragmentGenerator and URLTagFragmentGenerator (RA); * 02-Sep-2003 : Separated PNG encoding from writing chart to an *               OutputStream (RA); * 04-Dec-2003 : Chart draw() method modified to include anchor point (DG); * 20-Feb-2004 : Edited Javadocs and added argument checking (DG); * 05-Apr-2004 : Fixed problem with buffered image type (DG); * 01-Aug-2004 : Modified to use EncoderUtil for all image encoding (RA); * 02-Aug-2004 : Delegated image map related functionality to ImageMapUtil (RA); * 13-Jan-2005 : Renamed ImageMapUtil --> ImageMapUtilities, removed method *               writeImageMap(PrintWriter, String, ChartRenderingInfo) which *               exists in ImageMapUtilities (DG); * ------------- JFREECHART 1.0.x --------------------------------------------- * 06-Feb-2006 : API doc update (DG); * 19-Mar-2007 : Use try-finally to close output stream in saveChartAsXXX() *               methods (DG); * 10-Jan-2008 : Fix bug 1868251 - don't create image with transparency when *               saving to JPEG format (DG); * 02-Jul-2013 : Use ParamChecks class (DG); * */"
// autoWidthGap
// BOTTOM
/* TimeSeries result = */
// locale shouldn't matter here
// stripWidth
// axisOffset
// test findDomainBounds as well
// check the bounds of a simple dataset
// axis
// blockHeight
// blockWidth
// paintScale
// shapeOutlineVisible
// stripOutlinePaint
// stripOutlineStroke
// Anwender hat abgebrochen.
// line
// simple case
// shapeAnchor
// is the clone independent
// lineStroke
// try deleting null
// if we modify the original list, it's best if the URL generator is // not affected
// the clone contains a reference to the original object
// start with the current tick unit...
// try null calendar
// all tick labels have the same width (equal to the height of // the font)...
// check null argument 1
// check that clone is independent of the original
// check sorted rows
// the clone contains a reference to a CLONE of the original object
// try null key
// confirm that the clone is independent of the original
// replace an existing value
// request width index == itemCount
// try row index too high
// check handling of null key
// check null argument
// check null list
// Scaling with a factor of 1 does not change the range
// try unknown key
// try key index == itemCount
// try negative key index
/*Range r2 =*/
// Lower > upper: mid point is used
// Expand by 0% does not change the range
// map a key to a new group
// check an empty dataset
// autoSort
// remove an item
// add a value
// calculate midnight of first monday after 1/1/1900 relative to // current locale
// try null keys
// now overwrite group "G2"...
// a new map always has 1 group (the default group)
// text
// the default group is always at index 0
// if the default group is not mapped to, it should still count towards // the group count...
// indices are assigned in the order that groups are originally mapped
// check invalid indices
// a non-existent group should return -1
// a null argument should throw an exception
// a small check for independence
/* Number n = */
// try an array containing a single Number
/* Comparable k = */
// try column index too high
// try negative column index
// try null column key
// try null row key
// try unknown row key
// try null
// try a null source
// basic check for independence
// it's OK to use an index equal to the size of the list
// this is expected
// defer argument checks...
// test null source
// check that two empty datasets are equal
/* Number n =*/
// another item
// increment an unknown row
// increment a null value
// a row of all null values is still counted...
// LEFT
// increment an unknown column
// rotation anchor
/* Number start = */
// define subtasks
// note that we don't define taskB1
/* int count = */
/* Number end = */
// what if we don't want the interval?
// simple check for independence
// try a single item
// a dataset with a single value
// an item in series 2
// null is ignored
// pass on the event to the auxiliary handlers
// check another regular value
// adding a second series
// advance line Paint
// overwrite the value
// check a NaN
// check a null value
// does nothing unless overridden
// an empty dataset should return a null max
// and that simple aggregation works
// got it!
// Double.NaN DOESN'T mess things up
// empty dataset returns null
// null range throws IllegalArgumentException
// null list throws IllegalArgumentException
// try a Double.NEGATIVE_INFINITY
// try some nulls
/* TimeSeries s = */
//no initial zoom rectangle exists but the handler is set //as life handler unregister
// add a second series
// an empty dataset should return null for bounds
// try a Double.NaN
//gets the outline stroke width of the plot
// Add exception in included segments
// try a dataset with two values
// try null list
// Saturday and Sundays are non business hours
// try a list containing a single value
// test empty series
// try an array containing a single Number and a NaN
// try single value
// try a null argument
// try a collection with a single number
// try an empty collection
// try a collection with several numbers
// try zero length array
// try a collection with a single number plus a NaN
// check list containing null
// we call refresh ticks just to get the maximum width or height
// check empty list
/*item = */
// copy a range that begins before and ends in the middle of the // series...
// try deleting a time period that doesn't exist...
// copy a range that includes only the first item in the series...
// copy the last item...
// capLength
// copy just the first item...
// copy the first two items...
// copy the last two items...
// rotation angle
// try an array containing no items
//did zero tick last iteration //clear flag //create tick label string: //show tick label if "1e#"-style and it's one // of the first two, if it's the first or last // in the set, or if it's 1-5; beyond that // show fewer as the values get larger:
// changing the overwritten record shouldn't affect the series
// store the plot and its weight
// check negative first argument
// can't get anything yet...just an exception
//first tick of series, or not too small a value and // one of first 3 ticks, or last tick to be displayed // set exact number of fractional digits to be shown // (no effect if showing "1e#"-style ticks):
/*TimeSeriesDataItem item =*/
// test series with one item
// test series with two items
//private int autoTickIndex; //protected double reservedForTickLabels; //protected double reservedForAxisLabel;
// tests with values
// try null array
//negatives allowed or upper bound not between 0 & 1 //if flag then change to log version of highest value to // make range begin at a 10^n value; else use nearest int
// this line triggers the defect
// test a series with two items
// test 1...
//negatives not allowed and lower range bound is zero //use data range bound instead
// null items are ignored
// test 3...
//if less than 1.0 then make it 1.0 //subtract out margin and get exponential value:
// domain description - null
// range description
// a null item should throw an IllegalArgumentException
// test 2...
// add a fourth time period
// check empty dataset
// range description - null
// restore the default time zone
// work out the maximum height or width of the non-shared axes...
// first day of week is Sunday
// now add a second value to the series...
// add a third time period
// now test with a single value in the series...
// try null zone
// first day of week is monday
// now remove series 2 from collection 1 to make them equal again
// newly created collections should be equal
// now add the same series to collection 2 to make them equal again...
// shapeVisible
// Make sure there's nothing left
// the moving average series has 7 items, the first three // days (11, 12, 13 August are skipped)
// look at lower and upper bounds...
// for efficiency, we just use the first, last and middle items to // compute a hashCode...
// now add another series
// and check the first series too...
// CASE 1 : Comparing to another Second object // -------------------------------------------
// we clone the chart because presumably there can be some delay // between putting this instance on the system clipboard and // actually having the getTransferData() method called...
//if flag then change to log version of lowest value // to make range begin at a 10^n value:
// add an empty series
// add a series
//float midX = (float) (minX + (plotArea.getWidth() * getRotateX())); //float midY = (float) (minY + (plotArea.getHeight() * getRotateY()));
// call parent method // setup flag based on bounds values
// check for series key out of bounds
// after setting up all the subplots, the shared range axis may need // reconfiguring
// check that adding a series will overwrite the old series
// xHigh
// first check that a valid renaming works
// next, check that setting a duplicate key fails
// got the required exception
//negatives not allowed and upper bound between 0 & 1 //round up to nearest significant digit for bound: //get negative exponent:
// try an index out of bounds
// still 2
// check null key
// hasn't implemented RangeInfo, so we'll have to iterate...
// xLow
// yHigh
// yLow
//  Test that there are 6 X points and some specific values
// the series name should not  // change because "C" is already the key for the other series in the // collection
//  Remove series 1
// after adding a point to a series, check that there are now 7 // items in each series
//  Test that there are still 7 X points
// WITH AUTOPRUNING
//  Test that there are now 4 X points
// establish the coordinates of the top left corner of the drawing area
// 1 value pruned.
// WITHOUT AUTOPRUNING
// still 2.
// here we do a check to see if the user is installing the "Legacy" // theme, and reset the bar painters in that case...
// if the current stroke is not a BasicStroke then it is handled as // a special case
// FIXME: add setBaseItemLabelGenerator(CategoryItemLabelGenerator, //            boolean) ?
// text anchor
// milliseconds somewhere in 2006
// starts at back and wraps right around to the // back again
//  double range = this.domainAxis.getRange().getLength(); //  double scaledRange = range * percent; //  domainAxis.setAnchoredRange(scaledRange);
// the pie sections are arranged ANTICLOCKWISE
// if this cell held a maximum and/or minimum value, we'll need to // update the cached bounds...
// handle a special case - if the bar colour has alpha == 0, it is // invisible so we shouldn't draw any shadow
// For the case were the first tick is greater // than minZ
// retrieve an item
// key
// if we are drawing a perfect circle, we need to readjust the top left // coordinates of the drawing area for the arcs to arrive at this // effect.
// draw the sections at the top of the pie (and set up tooltips)...
/////////////////////////////////////////////////////////////////////////// // From HighLowDataset ///////////////////////////////////////////////////////////////////////////
// deregister the collection as a change listener to each series in // the collection.
// average radius // outlier radius
// These are deliberately not bounded to minimums/maxCandleWidth to //  retain old behaviour.
// errorPaint
// positive paint
// the first initialization must precede creation of the ValueSet array: // establishes length of each array
// starts at the back and finishes at the front // (wrapping the left side)
// if the 'notify' flag has been switched to false, we don't notify // the listeners
// errorStroke
// FIXME: add setSeriesToolTipGenerator(int, CategoryToolTipGenerator, //            boolean) ?
/* shape outlined = */
// the intersect is at the next point for both the minuend // and subtrahend
// draw outliers // outlier radius
// coordinate pairs // current minuend point // next minuend point // current subtrahend point // next subtrahend point
// map
// Check if the item is the last item for the series and number of // items > 0.  We can't draw an area for a single point.
// the bounds should be calculated using just the items within // the current range of the x-axis...if there is one
//if less than 1.0 then make it 1.0 //add in margin and get exponential value:
// labelLinkPaint
// paintList
// calculate plotAreas of all sub-plots, maximum vertical/horizontal // axis width/height
// OPTIONAL CUSTOMISATION COMPLETED.
//// ITEM LABEL PAINT  /////////////////////////////////////////////////////
// itemLabelGenerator
// create the new color and set it to the // SwtPaintCanvas
// seriesOutlineStroke
//private boolean autoTickUnitSelection;
// is there an override?
////////////////////////////////////////////////////////////////////////// // test exception segments //////////////////////////////////////////////////////////////////////////
// quadrant origin
// now check that all datasets, renderers and axes are being listened // too...
// background paint
// work out the mid angle (0 - 90 and 270 - 360) = right, // otherwise left
// these methods should throw an IndexOutOfBoundsException since the // column is too high...
// range markers
// regular equality for the datasets doesn't check the fields, just // the data values...so let's check some more things...
// after clearing, reverts to // default group
// nothing defined - do we autoPopulate?
// the dataset should prevent the addition of a series with the // same name as an existing series in the dataset
// null argument check delegated...
// the explode area defines the max circle/ellipse for the exploded // pie sections.  it is defined by shrinking the linkArea by the // linkMargin factor.
// secondary range markers
// delegate...
// rotationAnchor
// no axis, no gridlines...
// include legend // tooltips // urls
// rotationAngle
// can't zoom domain axis
// get the source coordinate - this plot has always a VERTICAL // orientation
// toolTipText
// the above should cover all the options...
// have to use a subclass of // AbstractRenderer
// test monday though friday timeline
// find first Monday after 2001-01-01
// no domain axis to zoom
// stroke index
////////////////////////////////////////////////////////////////////////// // test construction process //////////////////////////////////////////////////////////////////////////
// TBLRC // 00001 - center item only
// SERIES VISIBLE IN LEGEND (not yet respected by all renderers)
// expandToFitSpace
// category 1
// PAINT
// STROKE
// basePaint
// category 2
// value 2
// FIXME: calculate xx0
// LEFT POLYGON
// y date format
// margin
// current data point...
// clip left and right bounds to data area
// z date format
// domain description
// calculate bar width...
// the indicator bounds is calculated from the templateValue (which // determines the minimum size), the maxTemplateValue (which, if // specified, provides a maximum size) and the actual value
// chart title // data // include legend
// get a reference to the plot for further customisation...
////////////////////////////////////////////////////////////////////////// // test timeline translations //////////////////////////////////////////////////////////////////////////
// shapesVisible
// handle zoom box
// ok, exception is expected
// do nothing, override if necessary
//private boolean autoRangeStickyZero;
// majorTickIncrement // majorTickLength // majorTickPaint // majorTickStroke // minorTickCount // minorTickLength // minorTickPaint // minorTickStroke // tickLabelOffset // tickLabelFont // tickLabelsVisible // tickLabelFormatter // firstTickLabelsVisible
"/* (non-Javadoc)     * @see org.eclipse.swt.events.FocusListener#focusLost(     * org.eclipse.swt.events.FocusEvent)     */"
"/* (non-Javadoc)     * @see org.eclipse.swt.events.FocusListener#focusGained(     * org.eclipse.swt.events.FocusEvent)     */"
// ignoreZeroValues
// open
// new entity code
// disable bar outlines...
//TODO private boolean fillZoomRectangle = true;
// start new row
// width is OK, but height must be constrained
// start new column
/* x-axis label*/
// use gradients and white borders for the section colours
// DEPRECATED FIELDS AND METHODS...
// swap rows and columns to match plotArea shape
// draw the markers...
// super.setSeriesPaint(series, paint);
// add the insets
// for data in ascending order by x-value, we are (broadly) looking // for the index of the highest x-value that is less than xLow
// subtitle 1 is the legend
// BAR Y
// calculate the maximum allowed candle width from the axis...
// draw the outline...
// check that a legend item needs to be displayed...
// work out the label anchor point...
// higlight the background corners...
// fast-forward through leading tails
// get the x and y coordinates
// itemLabelFontList // baseItemLabelFont // itemLabelPaintList // baseItemLabelPaint // positiveItemLabelPositionList // basePositiveItemLabelPosition // negativeItemLabelPositionList // baseNegativeItemLabelPosition // itemLabelAnchorOffset // createEntityList // baseCreateEntities
// here we check that the average marker will in fact be visible // before drawing it...
// check that minItem limit is observed
//assert itemIndex >= 0 && itemIndex < getItemCount();
// skip if chart is null
//SwtGraphics2D sg2 = new SwtGraphics2D(e.gc);
// AXIS 2
// for value in bounds, do the lookup...
// shapeFilled
// domainAxis - no longer a separate field but test anyway...
//itemLabelPaint;
// separatorStroke
// sectionDepth
// we don't know anything about the ordering of the x-values, // but we can still skip any trailing values that fall outside the // range...
// rangeAxis - no longer a separate field but test anyway...
//extraLargeFont
// renderer - no longer a separate field but test anyway...
// leave the y values (y1, y0) untranslated as it is going to be be // stacked up later by previous series values, after this it will be // translated.
//largeFont
// set up the series names...
//regularFont;
// there should be no change event when clearing an empty series
//titlePaint;
// clean up
// anchorValue
// tick marks visible flag...
// TBLRC // 01111
// tick label font...
// anti-aliasing
// rangeCrosshairPaint
// draw outliers
// FIXME: add setBasePaint(int, Paint, boolean)?
// ITEM URL GENERATOR
/* BufferedImage img =*/
//SerialUtilities.writeImage(this.image, stream);
// process all renderers
// reserve space for the primary domain axis...
// draw the bottom circle
// range markers - no longer separate fields but test anyway...
// set a custom background for the chart
// process all range axes
/* line visible */
/* shape outlined */
/* line visible = */
//subtitlePaint;
// calculate the bar width
// -------------------------- // --- ChartPanel Methods --- // --------------------------
// ------------------------ // --- Member Variables --- // ------------------------
// ----------------- // --- Constants --- // -----------------
// process all domain axes
// Cycle when necessary
// wait till we are at the last item for the row then draw the // whole stack at once
// ---------------------- // --- Public Methods --- // ----------------------
// do nothing at all
// add the chart title, if one has been specified...
// by default the outline and background won't be visible
// process all annotations
"/* in the next zoomPoint.x and y replace by e.x and y for now.         * this helps to handle the mouse events and besides,         * those values are unused AFAIK. */"
// LineRenderer3D
// BarRenderer3D
// this fires a ChartChangeEvent
// added the following hint because of  // http://stackoverflow.com/questions/7785082/
// clear the section attributes so that the theme's DrawingSupplier // will be used
// if the flag is being set to true, there may be queued up changes...
// draw the title and subtitles...
// ensure no drawing occurs outside chart area...
// handle GradientPaint as a special case
// do not notify while zooming each axis
// private boolean borderVisible; // private transient Stroke borderStroke; // private transient Paint borderPaint;
// this generates the change event too
// use ImageIcon because it waits for the image to load...
// load only when required
// seem to be the same
// FIXME //this.image = SerialUtilities.readImage(stream);
// if we don't have at least 2 (x, y) coordinates, just return
// FIXME //SerialUtilities.writeImage(this.image, stream);
// return a new chart containing the overlaid plot...
//this.image = SerialUtilities.readImage(stream);
// add a second dataset and renderer...
// create plot ...
//  create transform & transform shape
// compute transform matrix elements via sample points. Assume no // rotation or shear.
// when zooming to sub-millisecond ranges, it can be the case that // adjEnd == adjStart...and we can't have an axis with zero length // so we apply this instead:
// baseCreateEntities;
//for each power of 10 value; create ten ticks
// handle axis trace
// AXIS 4
// or redrawing the chart every time...
// regular number axis
// what is the available space for one unit?
// all tick labels have the same width (equal to the height of the // font)...
// there are no more candidates
// It's up to the plot which clones up to restore the correct references
// if the axis has a fixed dimension, return it...
// displayStart > displayEnd, need to handle split
// no plot, no data.
//negative values not allowed
//get log10 version of upper bound and round to integer:
// is the category valid?
//setup number formatter obj
// add space for the outer tick labels, if any...
// this is the first period, but it is only partially visible // so check that the label will fit before displaying it...
// legendTextPaint
// work out the initial gap
// draw minor tick marks
// work out the trailing gap
// if autoRange is true, then the current range is irrelevant
// calculate the max size of the tick labels (if visible)...
// need to work out the space used by the tick labels... // so we can update the cursor...
//return value; negate if original value was negative:
//invert adjustLog10
//calculate ceil using negative value:
//negative values are allowed
//get lower bound value:
//parameter value is -10 > val < 10 //use as-is
// if < 10 then //increase so 0 translates to 0
//setup for "1e#"-style tick labels or regular // numeric tick labels, depending on flag:
//calculate floor using negative value:
//setup flag based on bounds values
//no real data present
//need to account for case where upper==0.0
//actual data is present //get lower bound value
//apply lower margin by decreasing lower bound:
//strict flag set, allow-negatives not set and values <= 0
//not small log values in use; allow for values <= 0 //if did zero tick last iter then
//no tick label to be shown
//create tick label (force use of fmt obj):
//create tick label:
//for each tick to be displayed
//if autorange still below minimum then adjust by 1% // (can be needed when minRange is very small):
//not "1e#"-type label // if positive exponent then // make integer
//not "log10"-type label
//tick value is 1.0 and 0.0 is within data range //set tick value to zero //indicate zero tick
//small log values in use
// did not do zero tick last iteration
//not small log values in use; allow for values <= 0 //if did zero tick last iter then //decrement to do 1.0 tick now //calculate power-of-ten value for tick:
//for each tick with a label to be displayed
//tick value not below lowest data value
// if past highest data value then exit // method
//negative exponent; create fractional value //set exact number of fractional digits to // be shown:
//if flag then //create "1e#"-type label
//get lower bound value
// ITEM_LABEL_PAINT
//create "1e#"-type label
// check the new minimum date relative to the current maximum date
//decrement to do 1.0 tick now
//first or last tick on graph or value is 1.0 //create label for tick:
//create "log10"-type label
// milliseconds
// not first tick of group //no label //make sure flag cleared
//create tick object and add to list:
//if past highest data value then exit method
// did zero tick last iteration //no label //clear flag
// date formatters
// usually the range will be a DateRange, but if it isn't do a // conversion...
//if flag then //create "log10"-type label
//using exponents or force-formatter flag is set // (convert 'E' to lower-case 'e'):
// check the new maximum date relative to the current minimum date
// get a locale-specific resource bundle...
// draw the chart background...
// then extrapolate...
// even though the axis is not visible, we need to refresh ticks in // case the grid is being drawn...
// days
// minutes
//Timeline hasn't method getStartTime()
// years
// months
// hours
// make final selection...
// could add a flag to make the following correction optional...
// 'tickMarkPosition' is immutable : no need to clone
// no action required.
// 'dateTickUnit' is immutable : no need to clone
// record the chart area, if info is requested...
// step down in size until the current size is too small or there are  // no more units
// now process the plot if there is one
// if there is no specific font, use the general one...
// if there is no specific paint, use the general one...
// nothing required
// find first excluded base segment starting fromDomainValue
// make a time zone with no DST for our Calendar calculations
//////////////////////////////////////////////////////////////////////////// // predetermined segments sizes ////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////// // static block ////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////// // other constants ////////////////////////////////////////////////////////////////////////////
// move forward exceptionSegmentCount segments skipping // excluded segments
// last series, so we are ready to draw the min and max
//////////////////////////////////////////////////////////////////////////// // operations ////////////////////////////////////////////////////////////////////////////
// verify that baseTimeline is compatible with us
// calculate the result as if no exceptions
// find all consecutive included segments
// adjust result for any exceptions in the result calculated
// skip exception or excluded segments we may fall on
// skip all whole exception segments in the range
// add the interval as an exception
// first check that autoPopulate==false works as expected
// long start = Math.max( //     fromSegment.getSegmentStart(), this.segmentStart // ); // long end = Math.min(toSegment.getSegmentEnd(), this.segmentEnd);
// cycle over all the base segments groups in the range
// cycle through all the segments contained in the base exclusion // area
// go to next base segment group
// If tick overlap when cycling, update last tick too
// calculate the adjusted data area taking into account the 3D effect...
// check if we need to collect chart entities from the container
// suppresses compiler warnings
// seriesOutlinePaint
// update, but dont draw tick marks (needed for stepped colors)
// inverted
// draw mean - SPECIAL AIMS REQUIREMENT...
// allow fixed thickness
// default make height of plotArea
// remember these values for next comparison
// transparent
// ensure that all the symbols are displayed
// catches null also
// this ensure that the grid bands will be displayed correctly.
// must be top or bottom
// From outlier array sort out which are outliers and put these into a // list If there are any farouts, set the flag on the // OutlierListCollection
// zap the buffer onto the canvas...
// avoid possible sun.dc.pr.PRException: endPath: bad path
// null is handled fine here...
// place in this row (truncated) anyway
// find optimum height, then map to range
//Block b = (Block) blocks.get(i);
// can safely ignore
// handle tool tips in a simple way
// find optimum width and map to range
// since the flow layout is relatively straightforward, no information // needs to be recorded here
// chart title // data // no legend // tooltips // no URL generation
// this default implementation will just fill the available // border space with a single color
// nothing to clear
// fixed width
// find optimum height and map to range
// if the area has zero height or width, we shouldn't draw anything
// check if initial polygon needs to be clipped
// place in this column (truncated) anyway
// autoRange
// customise the section label appearance
// pass to the super-class for handling
// add a subtitle giving the data source
// Insets values
// figure out what type of axis we have and instantiate the // appropriate panel
// create a panel for the settings...
// populate the deprecated fields
//      end fix by rfuller
// pass to super-class for handling
// update the deprecated field
//same as for ChartEntity!
// then the axis properties...
// check the deprecated fields
// update the deprecated fields
// try the parent plot
// FIXME
//      fix by rfuller
//dmo added //dmo added
// baseSeriesPaint
// record the plot area...
// title // x-axis label // y-axis label
// set the default stroke for all series
// does nothing unless overridden        
// force a redraw
// the URL text should already have been escaped by the URL generator
//if we have been panning reset the cursor //unregister in any case
// the actual panning occurs later in the mouseDragged() method
/// we have rotation huston, please spin me
// no fields to test
// we expect the line to be vertical or horizontal // vertical
//int maxX = (int) (plotArea.getMaxX());
// isArrowAtTop
// horizontal
/// we have rotation houston, please spin me
// configure the range axis...
// draw the shared axis
// set the width and height of non-shared axis of all sub-plots
// calculate sub-plot area
// default preserves previous // behaviour
// the range axis is deserialized before the subplots, so its value // range is likely to be incorrect...
// the pie area defines the circle/ellipse for regular pie sections. // it is defined by shrinking the explodeArea by the explodeMargin // factor.
// draw all the charts
// the explode area defines the max circle/ellipse for the exploded pie // sections. // it is defined by shrinking the linkArea by the linkMargin factor.
// get the data source - return if null;
// this is a paint we don't recognise
// the link area defines the dog-leg point for the linking lines to // the labels
// if too any elements
// do nothing by default.
// if depth is negative don't draw anything
// and finishes at back
// the segment starts at the front, and wraps all // the way around // the back and finishes at the front again
// start at front
// draw the height
// for CLOCKWISE charts, the extent will be negative...
// cycle through again drawing only the sides at the front...
// segments wraps right around the back...
// segment starts at back
// and finishes at the front
// whole segment stays at the back
// segments starts at front and finishes at back...
// segment only occupies the front
//dmo //zero when the parameter is not set
// never updated the subtrahend if it is implied to be zero
// draw horizontal crosshair if required...
// draw vertical crosshair if required...
// ratio represents axis units
// ratio represents pixels
// draw the plot background...
// get the data points
// segment starts at the front
// just the horizontal axis...
// just the vertical axis...
// end of column
// the following relies on the fact that the intervals are immutable
// seriesPaintList
// this is a new column
// plot the data (unless the dataset is null)...
//Object oldValue = this.urlGenerator;
//Object oldValue = this.toolTipGenerator;
// draw the background
// can't find any difference
// intentionally blank
// set the anchor value for the range axis...
// make the link area a square if the pie chart is to be circular...
// send a dataset change event to self to trigger plot change event
// check if line segments are colinear
// delegate
// AXIS 3
//  range = this.rangeAxis.getRange().getLength(); //  scaledRange = range * percent; //   rangeAxis.setAnchoredRange(scaledRange);
// add a tooltip for the section...
// draw all the subplots
// the segment starts at the back (still extending // CLOCKWISE)
// override is only for documentation purposes
// y is minor
// if not, check if there is a stroke defined for the specified key
// draw the wafer
//get major dimension
// otherwise look up the paint table
//ellipse diameter is the minor dimension
//set upperLeft point // x is minor
// calculate and draw the notch // horizontal orientation is considered notch right // vertical orientation is considered notch down
//// SECTION PAINT ////////////////////////////////////////////////////////
//// SECTION OUTLINE STROKE ///////////////////////////////////////////////
// seriesPaint
// cycle through once drawing only the sides at the back...
// classify the keys according to which side the label will appear...
// clear the point vectors
// no range axis // no renderer
// draw the right labels...
// draw the labels...
// can't find any difference...
//hh * getInteriorGap();
// line not visible
// for a RadialGradientPaint we adjust the center and radius to match // the current pie segment...
// create the bounds for the inner arc
// set the anchor value for the vertical axis...
// after setting up all the subplots, the shared domain axis may need // reconfiguring
// delegate 'state' and 'source' argument checks...
// showValueLines
// column keys provide potential keys for individual pies
// update the section colors to match the global colors...
// calculate inner arc in reverse direction, for later // GeneralPath construction
// the columns variable is always >= rows
// add an entity for the pie section
// row keys provide potential keys for individual pies
"/* =========================================================== * JFreeChart : a free chart library for the Java(tm) platform * =========================================================== * * (C) Copyright 2000-2014, by Object Refinery Limited and Contributors. * * Project Info:  http://www.jfree.org/jfreechart/index.html * * This library is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as published by * the Free Software Foundation; either version 2.1 of the License, or * (at your option) any later version. * * This library is distributed in the hope that it will be useful, but * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public * License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this library; if not, write to the Free Software * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, * USA. * * [Oracle and Java are registered trademarks of Oracle and/or its affiliates. * Other names may be trademarks of their respective owners.] * * ----------------- * CategoryPlot.java * ----------------- * (C) Copyright 2000-2014, by Object Refinery Limited and Contributors. * * Original Author:  David Gilbert (for Object Refinery Limited); * Contributor(s):   Jeremy Bowman; *                   Arnaud Lelievre; *                   Richard West, Advanced Micro Devices, Inc.; *                   Ulrich Voigt - patch 2686040; *                   Peter Kolb - patches 2603321 and 2809117; * * Changes * ------- * 21-Jun-2001 : Removed redundant JFreeChart parameter from constructors (DG); * 21-Aug-2001 : Added standard header. Fixed DOS encoding problem (DG); * 18-Sep-2001 : Updated header (DG); * 15-Oct-2001 : Data source classes moved to com.jrefinery.data.* (DG); * 22-Oct-2001 : Renamed DataSource.java --> Dataset.java etc. (DG); * 23-Oct-2001 : Changed intro and trail gaps on bar plots to use percentage of *               available space rather than a fixed number of units (DG); * 12-Dec-2001 : Changed constructors to protected (DG); * 13-Dec-2001 : Added tooltips (DG); * 16-Jan-2002 : Increased maximum intro and trail gap percents, plus added *               some argument checking code.  Thanks to Taoufik Romdhane for *               suggesting this (DG); * 05-Feb-2002 : Added accessor methods for the tooltip generator, incorporated *               alpha-transparency for Plot and subclasses (DG); * 06-Mar-2002 : Updated import statements (DG); * 14-Mar-2002 : Renamed BarPlot.java --> CategoryPlot.java, and changed code *               to use the CategoryItemRenderer interface (DG); * 22-Mar-2002 : Dropped the getCategories() method (DG); * 23-Apr-2002 : Moved the dataset from the JFreeChart class to the Plot *               class (DG); * 29-Apr-2002 : New methods to support printing values at the end of bars, *               contributed by Jeremy Bowman (DG); * 11-May-2002 : New methods for label visibility and overlaid plot support, *               contributed by Jeremy Bowman (DG); * 06-Jun-2002 : Removed the tooltip generator, this is now stored with the *               renderer.  Moved constants into the CategoryPlotConstants *               interface.  Updated Javadoc comments (DG); * 10-Jun-2002 : Overridden datasetChanged() method to update the upper and *               lower bound on the range axis (if necessary), updated *               Javadocs (DG); * 25-Jun-2002 : Removed redundant imports (DG); * 20-Aug-2002 : Changed the constructor for Marker (DG); * 28-Aug-2002 : Added listener notification to setDomainAxis() and *               setRangeAxis() (DG); * 23-Sep-2002 : Added getLegendItems() method and fixed errors reported by *               Checkstyle (DG); * 28-Oct-2002 : Changes to the CategoryDataset interface (DG); * 05-Nov-2002 : Base dataset is now TableDataset not CategoryDataset (DG); * 07-Nov-2002 : Renamed labelXXX as valueLabelXXX (DG); * 18-Nov-2002 : Added grid settings for both domain and range axis (previously *               these were set in the axes) (DG); * 19-Nov-2002 : Added axis location parameters to constructor (DG); * 17-Jan-2003 : Moved to com.jrefinery.chart.plot package (DG); * 14-Feb-2003 : Fixed bug in auto-range calculation for secondary axis (DG); * 26-Mar-2003 : Implemented Serializable (DG); * 02-May-2003 : Moved render() method up from subclasses. Added secondary *               range markers. Added an attribute to control the dataset *               rendering order.  Added a drawAnnotations() method.  Changed *               the axis location from an int to an AxisLocation (DG); * 07-May-2003 : Merged HorizontalCategoryPlot and VerticalCategoryPlot into *               this class (DG); * 02-Jun-2003 : Removed check for range axis compatibility (DG); * 04-Jul-2003 : Added a domain gridline position attribute (DG); * 21-Jul-2003 : Moved DrawingSupplier to Plot superclass (DG); * 19-Aug-2003 : Added equals() method and implemented Cloneable (DG); * 01-Sep-2003 : Fixed bug 797466 (no change event when secondary dataset *               changes) (DG); * 02-Sep-2003 : Fixed bug 795209 (wrong dataset checked in render2 method) and *               790407 (initialise method) (DG); * 08-Sep-2003 : Added internationalization via use of properties *               resourceBundle (RFE 690236) (AL); * 08-Sep-2003 : Fixed bug (wrong secondary range axis being used).  Changed *               ValueAxis API (DG); * 10-Sep-2003 : Fixed bug in setRangeAxis() method (DG); * 15-Sep-2003 : Fixed two bugs in serialization, implemented *               PublicCloneable (DG); * 23-Oct-2003 : Added event notification for changes to renderer (DG); * 26-Nov-2003 : Fixed bug (849645) in clearRangeMarkers() method (DG); * 03-Dec-2003 : Modified draw method to accept anchor (DG); * 21-Jan-2004 : Update for renamed method in ValueAxis (DG); * 10-Mar-2004 : Fixed bug in axis range calculation when secondary renderer is *               stacked (DG); * 12-May-2004 : Added fixed legend items (DG); * 19-May-2004 : Added check for null legend item from renderer (DG); * 02-Jun-2004 : Updated the DatasetRenderingOrder class (DG); * 05-Nov-2004 : Renamed getDatasetsMappedToRangeAxis() *               --> datasetsMappedToRangeAxis(), and ensured that returned *               list doesn't contain null datasets (DG); * 12-Nov-2004 : Implemented new Zoomable interface (DG); * 07-Jan-2005 : Renamed getRangeExtent() --> findRangeBounds() in *               CategoryItemRenderer (DG); * 04-May-2005 : Fixed serialization of range markers (DG); * 05-May-2005 : Updated draw() method parameters (DG); * 20-May-2005 : Added setDomainAxes() and setRangeAxes() methods, as per *               RFE 1183100 (DG); * 01-Jun-2005 : Upon deserialization, register plot as a listener with its *               axes, dataset(s) and renderer(s) - see patch 1209475 (DG); * 02-Jun-2005 : Added support for domain markers (DG); * 06-Jun-2005 : Fixed equals() method for use with GradientPaint (DG); * 09-Jun-2005 : Added setRenderers(), as per RFE 1183100 (DG); * 16-Jun-2005 : Added getDomainAxisCount() and getRangeAxisCount() methods, to *               match XYPlot (see RFE 1220495) (DG); * ------------- JFREECHART 1.0.x --------------------------------------------- * 11-Jan-2006 : Added configureRangeAxes() to rendererChanged(), since the *               renderer might influence the axis range (DG); * 27-Jan-2006 : Added various null argument checks (DG); * 18-Aug-2006 : Added getDatasetCount() method, plus a fix for bug drawing *               category labels, thanks to Adriaan Joubert (1277726) (DG); * 05-Sep-2006 : Added MarkerChangeEvent support (DG); * 30-Oct-2006 : Added getDomainAxisIndex(), datasetsMappedToDomainAxis() and *               getCategoriesForAxis() methods (DG); * 22-Nov-2006 : Fire PlotChangeEvent from setColumnRenderingOrder() and *               setRowRenderingOrder() (DG); * 29-Nov-2006 : Fix for bug 1605207 (IntervalMarker exceeds bounds of data *               area) (DG); * 26-Feb-2007 : Fix for bug 1669218 (setDomainAxisLocation() notify argument *               ignored) (DG); * 13-Mar-2007 : Added null argument checks for setRangeCrosshairPaint() and *               setRangeCrosshairStroke(), fixed clipping for *               annotations (DG); * 07-Jun-2007 : Override drawBackground() for new GradientPaint handling (DG); * 10-Jul-2007 : Added getRangeAxisIndex(ValueAxis) method (DG); * 24-Sep-2007 : Implemented new zoom methods (DG); * 25-Oct-2007 : Added some argument checks (DG); * 05-Nov-2007 : Applied patch 1823697, by Richard West, for removal of domain *               and range markers (DG); * 14-Nov-2007 : Added missing event notifications (DG); * 25-Mar-2008 : Added new methods with optional notification - see patch *               1913751 (DG); * 07-Apr-2008 : Fixed NPE in removeDomainMarker() and *               removeRangeMarker() (DG); * 23-Apr-2008 : Fixed equals() and clone() methods (DG); * 26-Jun-2008 : Fixed crosshair support (DG); * 10-Jul-2008 : Fixed outline visibility for 3D renderers (DG); * 12-Aug-2008 : Added rendererCount() method (DG); * 25-Nov-2008 : Added facility to map datasets to multiples axes (DG); * 15-Dec-2008 : Cleaned up grid drawing methods (DG); * 18-Dec-2008 : Use ResourceBundleWrapper - see patch 1607918 by *               Jess Thrysoee (DG); * 21-Jan-2009 : Added rangeMinorGridlinesVisible flag (DG); * 18-Mar-2009 : Modified anchored zoom behaviour (DG); * 19-Mar-2009 : Implemented Pannable interface - see patch 2686040 (DG); * 19-Mar-2009 : Added entity support - see patch 2603321 by Peter Kolb (DG); * 24-Jun-2009 : Implemented AnnotationChangeListener (see patch 2809117 by *               PK) (DG); * 06-Jul-2009 : Fix for cloning of renderers - see bug 2817504 (DG) * 10-Jul-2009 : Added optional drop shadow generator (DG); * 27-Sep-2011 : Fixed annotation import (DG); * 18-Oct-2011 : Fixed tooltip offset with shadow generator (DG); * 20-Nov-2011 : Initialise shadow generator as null (DG); * 02-Jul-2013 : Use ParamChecks (DG); * 12-Sep-2013 : Check for KEY_SUPPRESS_SHADOW_GENERATION rendering hint (DG); * 10-Mar-2014 : Updated Javadocs for issue #1123 (DG); * 09-Apr-2014 : Remove use of ObjectList (DG); *  */"
// allocate storage for dataset, axes and renderers
//// ITEM LABELS VISIBLE //////////////////////////////////////////////////
//// SERIES PAINT /////////////////////////
// add the unique categories from this dataset
// don't let anyone draw outside the data area
// the first axis in the list is used for data <--> Java2D
// reserve space for any domain axes...
// get the legend items for the datasets...
// if there is a renderer, it draws the background, otherwise use the // default background...
// specify the anchor X and Y coordinates in Java2D space, for the // cases where these are not updated during rendering (i.e. no lock // on data)
// reserve some space for the range axis...
// add domain axes to lists...
// now render data items...
// set up the alpha-transparency...
// draw an outline around the plot area...
// draw the foreground markers...
// grab the plot's annotations
// iterate through the datasets that map to the axis and get the union // of the ranges.
// draw the bottom axes
// draw the left axes
// add range axes to lists...
// draw the right axes
// now check that the chart is usable...
// do nothing, because the plot is not pannable along the domain axes
// provides a 'no action' default
// draw the range grid lines, if any...
// stroke sequence
// AxisLocation is immutable, so we can just copy the maps
// some subclasses override this method completely, so don't put // anything here that *must* be done
// delegate to other method
// not currently serialized
// headPercent
// square
// check null argument...
// we don't need the sign
// baseSectionPaint
// the datasets are not cloned, but listeners need to be added...
// fillType == TO_UPPER_BOUND
// normalize angle
// draw the radius grid lines, if any...
// now for each dataset, get the renderer and the appropriate axis // and render the dataset...
"/*      solve linear system with tridiagonal n by n matrix a        using Gaussian elimination *without* pivoting        where   a(i,i-1) = sub[i]  for 2<=i<=n        a(i,i)   = diag[i] for 1<=i<=n        a(i,i+1) = sup[i]  for 1<=i<=n-1        (the values sub[1], sup[n] are ignored)        right hand side vector b[1:n] is overwritten with solution        NOTE: 1...n is used in all arrays, 0 is unused */"
// horizontal ellipse
// horizontal rectangle
// up-pointing triangle
// right-pointing triangle
// this represents the situation // for drawing a horizontal bar.
// left-pointing triangle
// vertical rectangle
// otherwise look up the paint list
// draw the polygon series...
// verify independence of fixed legend item collection
//// SERIES OUTLINE STROKE /////////////////////
// draw the axis and category label
// plot the data...
// Now actually plot each of the series polygons..
// 1 = end of axis
// find the point at the appropriate distance end point // along the axis/angle identified above and add it to the // polygon
/* shapeFilled=*/
// Finds our starting angle from the centre for this axis
// down-pointing triangle
// circle
// diamond
//  Check that the graph being served was created by the current user //  or that it begins with "public"
// set the anchor value for the horizontal axis...
// Plot the polygon
// draw range crosshair if required...
// put an elipse at the point being plotted..
// pass mouse down event if some ChartMouseListener are listening
// reserve space for the domain axes...
// allocate storage for datasets, axes and renderers (all optional)
//          negatives = true;
// if series are in rows, then the categories are the column keys
// Lastly, fill the web polygon if this is required
//  value = Math.pow(10,value);
// clone share data sets => add the clone as listener to the dataset
// no zooming possible
//  izV = steps*numSteps*(int)((value/minZ)/(maxZlog-minZlog)) + 2;
// reserve space for the range axes...
// is it a domain axis?
//render series in forward order
// draw background annotations
/// Draw N, S, E, W
//render series in reverse order
// draw foreground annotations
// render data items...
// no default renderer available
// we can't draw quadrants without a valid x-axis
// can't render anything without axes
// we can't draw quadrants without a valid y-axis
// use the TextTitle class because it is a concrete subclass
// if the event was caused by a change to series visibility, then // the axis ranges might need updating...
// we don't clone the listeners
/// Squares
// if there is an existing dataset, remove the plot from the list // of change listeners...
// draw the item shapes
// the textAlignment and the horizontalAlignment are separate things, // but it makes sense for the default textAlignment to match the // title's horizontal alignment...
// or is it a range axis?
// perform the zoom on each domain axis
// register the plot as a listener with its axes, datasets, and // renderers...
// lineVisible
//int transX = (int) (xx + ww * (x - domainMin) / domainLength); //int transY = (int) (yy - hh * (y - rangeMin) / rangeLength);
// we don't use the calendar or numberFormat fields, but equals(Object) // is failing without them being non-null
// images considered equal only if they're the SAME object // TODO: is there a way to do a better test?
//  draw units indicator
// already calculated // already calculated
// plot is registered as a listener with the existing axis...
// draw the cap if there is one...
// draw text value on screen
// draw start of normal range
//// FILL PAINT //////////////////////////////////////////////////////////
// draw the axis...
// draw start of warning range
// draw start of critical range
// pieIndex...
// draw range indicators...
// draw thermometer outline
// draw the border
// draw the outline of the filled polygon
// calculate the bounds of the template value
/* lineVisible= */
// urlText
// now find the text anchor point
// adjust text bounds to match string position
// draw the pointers
// draw the background if there is one...
// first, expand the viewing area into a drawing frame
// now do the minor tick marks
// otherwise look up the stroke table
// now fetch the row data - need to bear in mind that the row // structure may not have an entry for the column key, but that we // have already checked that the key is valid for the 2D structure
// SERIES VISIBLE (not yet respected by all renderers)
// otherwise look up the position list
// OUTLINE PAINT //////////////////////////////////////////////////////////
// otherwise look up the shape list
// otherwise look up the position table
//// ITEM LABEL FONT //////////////////////////////////////////////////////
//  Iterate and find all keys below threshold percentThreshold
// ITEM LABEL VISIBILITY...
// POSITIVE ITEM LABEL POSITION...
// otherwise look up the boolean table
//// ITEM LABEL PAINT  ////////////////////////////////////////////////////
// 'paint' : immutable, no need to clone reference
// NEGATIVE ITEM LABEL POSITION...
// 'baseStroke' : immutable, no need to clone reference
// 'outlinePaint' : immutable, no need to clone reference
// 'stroke' : immutable, no need to clone reference
// 'basePaint' : immutable, no need to clone reference
// skip any items that don't need including...
// 'baseItemLabelAnchor' : immutable, no need to clone reference
//create a temporary vector // set x to some arbitary value (used below)
// 'baseOutlineStroke' : immutable, no need to clone reference
// 'baseItemLabelFont' : immutable, no need to clone reference
// shapeList // baseShape
// in this case, every color has a unique value
// 'postiveItemLabelAnchor' : immutable, no need to clone reference
// 'itemLabelPaint' : immutable, no need to clone reference
// 'itemLabelFont' : immutable, no need to clone reference
// 'itemLabelsVisible' : immutable, no need to clone reference
// 'baseNegativeItemLabelAnchor' : immutable, no need to clone reference
// assign a color for each unique value
//System.err.print(" creating new outlier list ");
// === DEPRECATED CODE ===
// 'outlineStroke' : immutable, no need to clone reference
// listeners are not restored automatically, but storage must be // provided...
// handle special case where value is less that item zero
//// TOOL TIP GENERATOR ///////////////////////////////////////////////////
// special case where the highest x-value is < xLow
//// URL GENERATOR ////////////////////////////////////////////////////////
// more values than paints so map // multiple values to the same color
// if there is no plot, there is no dataset to access...
// return the overall setting, if there is one...
// end class wafermaprenderer
// when the x-values are descending, the upper bound is found by // comparing against xLow
// handle negative value
// FIXME: calculate xxLeft and xxRight
// end foreach map entry // end else
// handle positive value
// RIGHT POLYGON
// SHAPES FILLED
// '+' because v is negative
// handle value outside bounds...
// handle rendering separately for the two plot orientations...
// look for any keys that we don't already know about...
// draw the blocks
// the commented out code would be better, but only if // RendererChangeEvent is immutable, which it isn't.  See if there is // a way to fix this...
// SHAPES VISIBLE
// contained titles
// preserves old behaviour
// LINES VISIBLE
// value 0
// nothing is drawn for null...
// put an outline around the data area...
// fetch the series, remove the change listener, then remove the series.
// do nothing if both the line and shape are not visible
// cases 5, 6, 7 and 8
// get the clipping values...
// set the default item label positions
// fill background...
// highlight the background corners...
// ITEM LABEL GENERATOR
// draw the bar...
// check the value we are plotting...
// the bar is not visible
// URL GENERATOR
// TOOL TIP GENERATOR
// defensive check
// no new methods
// now draw the outlines, if visible...
// FIXME: add setSeriesOutlineStroke(int, Stroke, boolean) ?
// cases 1, 2, 3 and 4
// handle special case of BoxAndWhiskerDataset
// let the superclass handle it...
// standard deviation lines
// cases 9, 10, 11 and 12
// draw background image, if there is one...
//ChartEditorManager.getChartEditor(canvas.getDisplay(), this.chart);
// FIXME: add setSeriesOutlinePaint(int, Paint, boolean)?
// FIXME: add setBaseItemLabelPaint(Paint, boolean) ?
// DRAW THE BARS...
// nothing is drawn for null values...
//plotBackgroundPaint;
// no fields to compute...
// 100 percent, so it will not apply unless changed
// FIXME: add setBaseOutlineStroke(Stroke, boolean) ?
// units
//// SHAPE /////////////////////////////////////////////////////////////////
// remove old items if necessary, but // don't notify anyone, because that // happens next anyway...
// tick labels visible
// tick size
//standard deviation lines
// switch x and y
// upright bar
// extend x0's flat bar
// or: x0s + 2*(x0-x0s)
// or: x1s + 2*(x1-x1s)
// the clone and the original share a reference to the SAME dataset
//plotOutlinePaint;
//// OUTLINE PAINT /////////////////////////////////////////////////////////
// x1's flat bar
// FIXME: add setSeriesShape(int, Shape, boolean) ?
// BAR WIDTH
//// PAINT /////////////////////////////////////////////////////////////////
"/* =========================================================== * JFreeChart : a free chart library for the Java(tm) platform * =========================================================== * * (C) Copyright 2000-2013, by Object Refinery Limited and Contributors. * * Project Info:  http://www.jfree.org/jfreechart/index.html * * This library is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as published by * the Free Software Foundation; either version 2.1 of the License, or * (at your option) any later version. * * This library is distributed in the hope that it will be useful, but * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public * License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this library; if not, write to the Free Software * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, * USA. * * [Oracle and Java are registered trademarks of Oracle and/or its affiliates.  * Other names may be trademarks of their respective owners.] * * ------------------------- * CategoryItemRenderer.java * ------------------------- * * (C) Copyright 2001-2011, by Object Refinery Limited and Contributors. * * Original Author:  David Gilbert (for Object Refinery Limited); * Contributor(s):   Mark Watson (www.markwatson.com); * * Changes * ------- * 23-Oct-2001 : Version 1 (DG); * 16-Jan-2002 : Renamed HorizontalCategoryItemRenderer.java *               --> CategoryItemRenderer.java (DG); * 05-Feb-2002 : Changed return type of the drawCategoryItem method from void *               to Shape, as part of the tooltips implementation (DG) * *               NOTE (30-May-2002) : this has subsequently been changed back *               to void, tooltips are now collected along with entities in *               ChartRenderingInfo (DG); * * 14-Mar-2002 : Added the initialise method, and changed all bar plots to use *               this renderer (DG); * 23-May-2002 : Added ChartRenderingInfo to the initialise method (DG); * 29-May-2002 : Added the getAxisArea(Rectangle2D) method (DG); * 06-Jun-2002 : Updated Javadoc comments (DG); * 26-Jun-2002 : Added range axis to the initialise method (DG); * 24-Sep-2002 : Added getLegendItem() method (DG); * 23-Oct-2002 : Added methods to get/setToolTipGenerator (DG); * 05-Nov-2002 : Replaced references to CategoryDataset with TableDataset (DG); * 06-Nov-2002 : Added the domain axis to the drawCategoryItem method.  Renamed *               drawCategoryItem() --> drawItem() (DG); * 20-Nov-2002 : Changed signature of drawItem() method to reflect use of *               TableDataset (DG); * 26-Nov-2002 : Replaced the isStacked() method with the getRangeType() *               method (DG); * 08-Jan-2003 : Changed getSeriesCount() --> getRowCount() and *               getCategoryCount() --> getColumnCount() (DG); * 09-Jan-2003 : Changed name of grid-line methods (DG); * 21-Jan-2003 : Merged TableDataset with CategoryDataset (DG); * 10-Apr-2003 : Changed CategoryDataset to KeyedValues2DDataset in *               drawItem() method (DG); * 29-Apr-2003 : Eliminated Renderer interface (DG); * 02-Sep-2003 : Fix for bug 790407 (DG); * 16-Sep-2003 : Changed ChartRenderingInfo --> PlotRenderingInfo (DG); * 20-Oct-2003 : Added setOutlinePaint() method (DG); * 06-Feb-2004 : Added missing methods, and moved deprecated methods (DG); * 19-Feb-2004 : Added extra setXXXLabelsVisible() methods (DG); * 29-Apr-2004 : Changed Integer --> int in initialise() method (DG); * 18-May-2004 : Added methods for item label paint (DG); * 05-Nov-2004 : Added getPassCount() method and 'pass' parameter to drawItem() *               method (DG); * 07-Jan-2005 : Renamed getRangeExtent() --> findRangeBounds (DG); * 11-Jan-2005 : Removed deprecated code in preparation for 1.0.0 release (DG); * 23-Feb-2005 : Now extends LegendItemSource (DG); * 20-Apr-2005 : Renamed CategoryLabelGenerator *               --> CategoryItemLabelGenerator (DG); * 20-May-2005 : Added drawDomainMarker() method (DG); * ------------- JFREECHART 1.0.x --------------------------------------------- * 20-Feb-2007 : Updated API docs (DG); * 19-Apr-2007 : Deprecated seriesVisible and seriesVisibleInLegend flags (DG); * 20-Apr-2007 : Deprecated paint, fillPaint, outlinePaint, stroke, *               outlineStroke, shape, itemLabelsVisible, itemLabelFont, *               itemLabelPaint, positiveItemLabelPosition, *               negativeItemLabelPosition and createEntities override *               fields (DG); * 26-Jun-2008 : Added new method required for crosshair support - THIS CHANGES *               THE API as of version 1.0.11 (DG); * */"
// The next 3 functions override the base-class implementation of // the DomainInfo interface.  Using saved limits (updated by // each updateTime() call), improves performance. //
// BAR HEIGHT
// row 2: outline color
// FIXME: add setSeriesPaint(int, Paint, boolean)?
//// FILL PAINT /////////////////////////////////////////////////////////
// FIXME: add setSeriesStroke(int, Stroke, boolean) ?
//// STROKE ////////////////////////////////////////////////////////////////
// FIXME: add setBaseShape(Shape, boolean) ?
// FIXME: add setBaseOutlinePaint(Paint, boolean)?
// ITEM LABELS VISIBLE
//// OUTLINE STROKE ////////////////////////////////////////////////////////
// FIXME: add setSeriesItemLabelGenerator(int, CategoryItemLabelGenerator, //            boolean)
//// ITEM LABEL FONT  //////////////////////////////////////////////////////
// FIXME: add setBaseItemLabelFont(Font, boolean) ?
// FIXME: add setSeriesItemLabelPaint(int, Paint, boolean) ?
/*&& state.getBarWidth() > renderer.BAR_OUTLINE_WIDTH_THRESHOLD*/
// FIXME: add setSeriesItemLabelFont(int, Font, boolean) ?
// create an actual polygon
// create a line renderer only
// draw the upper shadow...
// connect to the previous point
// need to handle cluster centering as a special case
// first check the number we are plotting...
// 100 percent, so it will not apply unless // changed
// we'll set this to false if there is at // least one non-null data item...
// set the default item label positions, which will only be used if // the user requests visible item labels...
// calculate the box width
// treat the last column value as an absolute
// offset the start of the box if the box width is smaller than // the category width
// alternatively, sometimes the first few days of the year are // considered to fall in the *last* week of the previous year...
// draw the box...
"/*             * Legacy? Just return the original Paint.             * (this corresponds EXACTLY to how Paints used to be darkened)             */"
// Create a new Area for the series
// start from Y = rangeBase
// draw median...
// average radius
// draw yOutliers...
// draw the body...
// draw farout indicators
// disable visible items optimisation - it doesn't work for this // renderer...
// not just a horizontal bar but need to perform a 'step'.
// The first point is (x, this.baseYValue)
// check if series are disjoint (i.e. domain-spans do not overlap)
// TODO getSeriesShape(n).getBounds().height / 2;
// project onto minuend
// fill the polygon
// draw an outline around the Area.
// TODO getSeriesShape(n).getBounds().width / 2;
// do nothing...this is just a hook for subclasses
// start new area when needed (see above)
// draw optional guide lines
// calculate the arrow head and draw it...
// there are no fields to check
//labelLinkStyle;
// orientation is HORIZONTAL
// check if either series is a degenerate case (i.e. less than 2 points)
// try a listener type that isn't registered
//// ITEM LABEL FONT ///////////////////////////////////////////////////////
// state
// can't draw anything
// start of algorithm
// subtrahend needs to be fast forwarded
// DEPRECATED METHODS
// if the series is sorted, the negative index is a result from // Collections.binarySearch() and tells us where to insert the // new item...otherwise it will be just -1 and we should just // append the value to the list...
//// ANNOTATIONS //////////////////////////////////////////////////////////
// check for intersect
// deassert b_*FastForward (only matters for 1st time through loop)
// set new starting point for the polygon
// project onto subtrahend
// pass mouse move event if some ChartMouseListener are listening
// clear colinear points and flag
// compute numerators
// this won't happen :)
// compute the point of intersection
// check if the line segments intersect
// test if both grahphs have a vertical rise at the same x-value
// add intersection point to the polygon
//// PAINT ////////////////////////////////////////////////////////////////
// return straight away if the item is not visible
// add interection point to new polygon
// chart title // domain axis label // range axis label // data // orientation // include legend // tooltips? // URLs?
// set the maxY and minY values to intersect y-value
// labelType...
// add the last point of the minuned and subtrahend
// consider last point of minuend and subtrahend for determining // positivity
// check if the final polygon needs to be clipped
// the SWTGraphics2D class doesn't handle GradientPaint well, so // replace the gradient painter from the default theme with a // standard painter...
// advance the subtrahend if needed
//// VISIBLE //////////////////////////////////////////////////////////////
// advance the minuend if needed
// vertical orientation
// advance minuend and subtrahend to intesect
// a Range object cannot be equal to a different object type
// bad axisNumber
// compute slope components
//// DRAWING //////////////////////////////////////////////////////////////
// may be negative
//// OUTLINE PAINT ////////////////////////////////////////////////////////
// interval
// first pass draws the shading
//// OUTLINE STROKE ///////////////////////////////////////////////////////
//// SHAPE ////////////////////////////////////////////////////////////////
//// ITEM LABEL GENERATOR /////////////////////////////////////////////////
//// LEGEND ITEM LABEL GENERATOR //////////////////////////////////////////
//// LEGEND ITEMS /////////////////////////////////////////////////////////
// FIXME:
//  Get height adjustment based on stack and translate to Java2D values
// add an entity if this info is being collected
// if the renderer isn't assigned to a plot, then we don't have a // dataset...
//  On first pass render the areas, line and outlines
// Use a SwtPaintCanvas to show the color, note that we must set the // heightHint.
//  Get series Paint and Stroke
// start from previous height (ph1)
//labelLinkPaint;
//  Draw an outline around the Area.
// The first point is (x, 0)
// dial shape
// we need at least two points to draw something
// construct path
// if this is the last item, draw the path ...
// update path to reflect latest point
// now create a new title and replace the existing title, several // things should happen: // (1) Adding the new title should trigger an immediate //     ChartChangeEvent; // (2) Modifying the new title should trigger a ChartChangeEvent; // (3) Modifying the old title should NOT trigger a ChartChangeEvent
// On second pass render shapes and collect entity and tooltip // information
// Add points from last series to complete the base of the // polygon
// Collect points
// draw path
// construct spline // number of points // Newton form coefficients // x-coordinates of nodes
// we need at least 3 points to spline. Draw simple line // for two points
// we're running on JRE 1.3.1 so this is the best we have...
// note that a[0]=a[np-1]=0
// dial background paint
// get the label position..
// name
// just the range axis...
// then draw the line...
// fill under the curve...
// just the domain axis...
// now draw the real shape
/*      factorization and forward substitution */
// reset points vector
// should never get here
// map a key to the default group
// 'plot' : just retain reference, not a deep copy
// calculate the step point
//this handles the need to perform a 'step'.
//this handles the need to perform a 'step'. // calculate the step point
// submit this data item as a candidate for the crosshair point
// create a new area polygon for the series
// the first point is (x, 0)
// no change
// we make the clip region slightly larger than the // dataArea so that the clipped edges don't show lines // on the chart
// here we use BooleanUtilities to remain compatible with JDKs < 1.4
// update the max value
// need to make sure we are adding *after* any duplicates
// we needed to get this far even for invisible items, to ensure that // seriesPath updates happened, but now there is nothing more we need // to do for non-visible items...
// If the line is not wrapping, then parent is OK
// draw the body
// only draw a line if the gap between the current and // previous data point is within the threshold
// draw the lower shadow
// draw the upper shadow
// this method must be overridden if you want to display images
// first pass draws the background (lines, for instance)
//  Fill the polygon
//////////////////////////////////////////////////////////////////////////// // PROTECTED METHODS // These provide the opportunity to subclass the standard renderer and // create custom effects. ////////////////////////////////////////////////////////////////////////////
// Now split the segment as needed
// should not get here
// yOutliers can be null, but we'd prefer it to be an empty list in // that case...
// draw farout
// draw yOutliers
// minuend needs to be fast forwarded
// If null, don't draw line at all
//initalize xValues, yValues, and zValues arrays.
// Process outliers. Each outlier is either added to the appropriate // outlier list or a new outlier list is made
// If null, don't draw line => then delegate to parent
// calculate the highest volume in the dataset...
// draw the error bar for the y-interval
// draw the error bar for the x-interval
// transpose the dimensions, because the title is rotated
// include the interval if there is one
//domainGridlinePaint;
// no need to instantiate this class   
// handle item label drawing, now that we know all the bars have // been drawn...
// we didn't find the key
// update the crosshair point
// don't bother with parsing
// --- DEPRECATED CODE ----------------------------------------------------
// RectangleInsets is immutable => same reference in clone OK
//  Add chart to deletion list in session
//  Serve it up
//  Replace ".." with "" //  This is to prevent access to the rest of the file system
//  Set HTTP headers
// suppress compiler warning
// svgClass will be null so the function will return false
// determine the space required for the axis
// this includes the case where the underlying dataset is null
// get the lastest pixel
// first point is outside, so we update it against one of the // four sides then continue
// second point is outside, so we update it against one of the // four sides then continue
//reserve variables to store the coordinates of the resulting GradientPaint
// Red // Green // Blue
// ALWAYS null
// Red // Green // Blue. Now map computed colour to // nearest in Palette...
// RGB (+ optional Alpha which we leave // unchanged)
// <- this is the code that actually COPIES the pixels
"/*         * Buffered Images may have properties, but NEVER disclose them!         * Nevertheless, just in case someone implements getPropertyNames()         * one day...         */"
/* Ignore alpha-channel -> */
//get the coordinates of the shape that is to be filled
// substitute the filtered URL list
// all methods are static, no need to instantiate
// vertical pass
// substract the oldest pixel from the sum
//start point is upper left corner
/* (pix-buffer is large enough for all pixels of one row) */
//start point is lower left right corner --> diagonal gradient
// horizontal pass
// check that the column key is defined in the 2D structure
// consider these to be ordered after general objects
// this will include the case where the underlying dataset is null
// 1. check whether the row is now empty.
// but the row data requires a deep copy
//  Check the file exists
//int columnIndex = getColumnIndex(columnKey);
/* Placeholder */
// for the keys, a shallow copy should be fine because keys // should be immutable...
// no new methods required
// Map the nongrid data into the new regular grid
// does the series exist?
// Find min, max for the x and y axes
// fetch the value...
// update the data...
//step through all the values and add them to the hash
// store Number as Double
// scale by the inverse of distance^power
// if d is real small set the inverse to a large number // to avoid INF
// Determine the cell size
//remove distance of the sum
// the CategoryDataset interface expects a list of categories, but // we've stored them in an array...
//store data as Long
// remove all the series from the collection and notify listeners.
// set x to most recent value
//store index where new //column starts
// already know 'a' isn't null
// calculate constant values
// store y and z axes // as Doubles
//  Do not add key to dataset
// now try to instantiate this ;-)
// now do the work...
//  Add other category if applicable
//  Add key to dataset
// if the dataset implements DomainInfo, life is easier
/////////////////////////////////////////////////////////////////////////// // Private ///////////////////////////////////////////////////////////////////////////
// update the min value
// handle the standard case (plain CategoryDataset)
// create the temporary directory if it doesn't exist
/////////////////////////////////////////////////////////////////////////// // New methods from CombinationDataset ///////////////////////////////////////////////////////////////////////////
// handle special case of OHLCDataset
// handle special case of IntervalXYDataset
// if the dataset implements DomainInfo, life is easy
// work out the minimum value...
// minimum and maximum for each group...
// maps our series into our parent's
// add the series...
// more difficult case - evaluate later...
// Are we working with a time series.
// exact match on first item
// exact match
// delegate null check on dataset
// overridden to make public
// no crossing of x
// spanning match
// Might need to add, to free memory from any previous result sets
// no new methods added.
// prior to 1.0.14, we just fired a PropertyChange - so we need to // keep doing this
// not a value, can't use it (defaults to null)
// Remove any previous old data
// first line contains column keys
// first column contains the row key...
// remaining fields contain values
// suppress (value defaults to null)
// lower bounds are the same
// pretty sure this shouldn't ever happen
// first field is ignored, since // column 0 is for row keys
// fill the bins
/// First column is X data
/// Determine max and min values.
// Get all rows. // rows = new ArrayList();
// pass values to other constructor
// sum of x, x^2, x * y, y
// update the cached range values...
// update cached min and max values
// defer null argument checks
// intercept
// calculate the sum and count
// treat nulls the same as NaNs
// check for zero pivot element
// iterate over all data items and update mins and maxes
// update cached range values
// Tell the listeners a new table has arrived.
// make the change (if it's not a duplicate time period)...
// remove old items and notify if necessary
// we are at the last minute in the hour...
// won't get here...
// find the serial index of the period specified by 'latest'
// see comments about priority of // 10 in validateObject()
// getXxx() ftns can ignore the "series" argument: // Don't synchronize this!! Instead, synchronize the loop that calls it.
//rangeGridlinePaint;
// figure out if we need to iterate through all the y-values // to find the revised minY / maxY
// we are at the first hour in the day...
// if the hour is 0 - 23 then create an hour
// start is after last data item
// But if that series array already exists, just overwrite its contents //synchronized(this) //{
// we are at the last hour in the day...
// update the time series appropriately
// CASE 1 : Comparing to another Hour object // -----------------------------------------
// cached values used for interface DomainInfo:
// an arbitrary safe default value
// parse the string...
// work out the average for the earlier values...
// CASE 1 : Comparing to another Year object // -----------------------------------------
// default value;
// autoinit's to null.
// But if that series array already exists, just overwrite its contents
// create the year...
// remaining lines contain a row key and data values
// create an array holding the group indices for each series...
// if the initial averaging period is to be excluded, then // calculate the index of the // first data item to have an average calculated...
// Cached values used for interface RangeInfo: (note minValue pinned at 0) //   A single set of extrema covers the entire SeriesCollection
// Avoid IndexOutOfBoundsException:
/// Expand the following for all defined TimePeriods:
///  .. etc....
//{ // deep copy from values[], caller // can safely discard that array
// Methods for managing the FIFO's:
// handle special case of BoxAndWhiskerXYDataset
// a Long kept updated by advanceTime()
// else  [implicit here]
// no translation needed
// if the oldest data contained a maximum Y-value, invalidate the stored //   Y-max and Y-range data:
// Now advance "oldestAt", wrapping at end of the array
// index to select the "series"
// Update the domain limits: //(time is kept in msec)
// check whether the "valueHistory" array member exists; if not, // create them:
// find the Q and the integer following it (remove both from the // string)...
// the following code handles the line for the y-values...it's // all done by code in the super class
// Don't synchronize this!! // Instead, synchronize the loop that calls it.
// CASE 1 : Comparing to another Quarter object // --------------------------------------------
// NULL value -> insert point on base line // instead of 'step point'
// do nothing, so null is returned
// replace any / , or - with a space
// Update the array of TimePeriods:
// 1-ms test timeline using 5 included and 2 excluded segments. // // timeline start time = 0 //   | //   v //   0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 .. // +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+.. // |  |  |  |  |  |EE|EE|  |  |  |  |  |EE|EE|  |  |  |  |  |  |EE|EE|    <-- msTimeline // +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+.. //  \_________  ________/            \_/ //            \/                      | //       segment group         segment size = 1 ms //
// CASE 1 : Comparing to another Day object // ----------------------------------------
// we need to work out if the previous year has 52 or 53 weeks...
// to be defensive, let's check that the source series does in fact // belong to this collection
// check if the new series name already exists for another series
// 1-ms test timeline (with a baseTimeline) using 2 included and 2 // excluded segments centered inside each base segment // // The ms2Timeline without a base would look like this: // //    timeline start time = 1 //      | //      v //   0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 ... // +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+... // |EE|  |  |EE|EE|  |  |EE|EE|  |  |EE|EE|  |  |EE|EE|  |  |EE|    <-- ms2Timeline // +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+... //    \____  _____/            \_/ //         \/                   | //    segment group      segment size = 1 ms // // With the base timeline some originally included segments are now // removed (see "xx" below): // //   0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 ... // +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+... // |EE|  |  |EE|EE|xx|xx|EE|EE|  |  |EE|EE|xx|xx|EE|EE|  |  |EE|    <-- ms2Timeline // +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+... // |  |  |  |  |EE|EE|EE|EE|  |  |  |  |EE|EE|EE|EE|  |  |  |  |    <-- ms2BaseTimeline // +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+... //
// if it is not the series name, then we have no interest
// check arguments...delegated // fetch the series name...
// suppress
// CASE 1 : Comparing to another Week object // --------------------------------------------
// trim whitespace from either end of the string
//axisOffset;
// CASE 1 : Comparing to another Month object // --------------------------------------------
// all arrays equal length, // so ignore argument:
// --- DEPRECATED METHODS -------------------------------------------------
// now it is trickier to determine if the month or year is first
//  wipe the next (about to be used) set of data slots
// no attributes to read
//this.key = null;
//private Comparable key;
// we can't be sure of the order
// Remove all the series from the collection and notify listeners.
// check arguments...delegated
// need to configure the intervalDelegate to match the original
// add a new series
// false preserves the old behaviour // prior to introducing this flag
// everything is fine: autoWidth is on, and an autoIntervalWidth // was set.
// this.x is not allowed to be null...
// all series have the same number of items in // this dataset
// In version 0.9.12, in response to several developer requests, I changed // the 'data' attribute from 'private' to 'protected', so that others can // make subclasses that work directly with the underlying data structure.
// figure out if we need to iterate through all the y-values
// try a class that isn't a listener
